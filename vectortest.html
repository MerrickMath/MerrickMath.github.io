<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vector Target — Integer Linear Combinations</title>
  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#0f172a; --muted:#475569; --soft:#f8fafc; --card:#ffffff; --border:#e2e8f0;
      --a:#1d4ed8; --b:#059669; --target:#d97706; --combo:#7c3aed;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font:16px/1.45 ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; color:var(--ink); background:var(--bg);} 
    .wrap{max-width:1100px; margin:28px auto; padding:0 16px;}
    header{display:flex; align-items:baseline; gap:12px; margin-bottom:18px}
    h1{font-size:clamp(22px,3vw,32px); margin:0}
    .subtitle{color:var(--muted)}
    .row{display:flex; gap:16px; flex-wrap:wrap}
    .card{background:var(--card); border:1px solid var(--border); border-radius:14px; padding:14px}
    .title{font-weight:600; color:var(--muted); margin:0 0 8px 0}
    .katex{font-size:1.05rem}
    .btn{appearance:none; border:1px solid var(--border); background:var(--soft); color:var(--ink); padding:10px 12px; border-radius:10px; cursor:pointer}
    .btn:hover{filter:brightness(0.98)}
    .boards{display:grid; grid-template-columns:repeat(3,1fr); gap:16px; margin-top:8px}
    @media (max-width: 960px){ .boards{grid-template-columns:1fr} }
    svg.board{width:100%; height:340px; background:#fff; border:1px solid var(--border); border-radius:12px}
    .legend{display:flex; gap:16px; align-items:center; flex-wrap:wrap; color:var(--muted); font-size:14px; margin-top:8px}
    .key{display:inline-flex; align-items:center; gap:6px}
    .dot{width:12px; height:12px; border-radius:3px}
    .a{background:var(--a)} .b{background:var(--b)} .t{background:var(--target)} .c{background:var(--combo)}
    .note{margin-top:8px; color:var(--muted); font-size:14px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Vector Target</h1>
      <div class="subtitle">Find integers $m,n$ so that $m\,ec a + n\,ec b$ lands on the target point.</div>
    </header>

    <!-- Problem statement and Show Solution button -->
    <div class="row" style="align-items:center; justify-content:space-between">
      <div id="problem" class="katex"></div>
      <button id="showBtn" class="btn">Show Solution</button>
    </div>

    <!-- Small boards for individual vectors -->
    <div class="boards">
      <div class="card">
        <p class="title">Vector $ec a$</p>
        <svg id="boardA" class="board" viewBox="0 0 420 340"></svg>
      </div>
      <div class="card">
        <p class="title">Vector $ec b$</p>
        <svg id="boardB" class="board" viewBox="0 0 420 340"></svg>
      </div>
      <div class="card">
        <p class="title">Problem Board</p>
        <svg id="boardMain" class="board" viewBox="0 0 420 340"></svg>
        <div class="legend">
          <span class="key"><span class="dot a"></span> $ec a$</span>
          <span class="key"><span class="dot b"></span> $ec b$</span>
          <span class="key"><span class="dot t"></span> target</span>
        </div>
      </div>
    </div>

    <!-- Solution board appears at the bottom when toggled -->
    <div id="solutionWrap" class="card" style="display:none; margin-top:16px">
      <p class="title">Solution Board (auto‑fit)</p>
      <svg id="boardSolution" class="board" viewBox="0 0 1000 420"></svg>
      <div id="solution" class="katex" style="margin-top:10px"></div>
      <div class="legend">
        <span class="key"><span class="dot a"></span> $ec a$</span>
        <span class="key"><span class="dot b"></span> $ec b$</span>
        <span class="key"><span class="dot t"></span> target</span>
        <span class="key"><span class="dot c"></span> $m\,ec a + n\,ec b$</span>
      </div>
    </div>

    <p class="note">Click “Show Solution” to reveal one valid integer combination and a tip‑to‑tail visualization on a separate, auto‑sized board at the bottom. Reload to generate a new instance.</p>
  </div>

  <script>
    // -------- KaTeX initialization guard --------
    function waitFor(cond,{interval=50,timeout=8000}={}){return new Promise((res,rej)=>{const t=Date.now();(function chk(){if(cond())return res();if(Date.now()-t>timeout)return rej(new Error('Timeout'));setTimeout(chk,interval)})()})}

    // ---------- Random instance generation ----------
    const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a; // inclusive
    const det=(u,v)=>u.x*v.y-u.y*v.x;

    let A,B,target,mTrue,nTrue;

    function newInstance(){
      do{A={x:randInt(-5,5),y:randInt(-5,5)}}while(A.x===0&&A.y===0);
      do{B={x:randInt(-5,5),y:randInt(-5,5)}}while((B.x===0&&B.y===0)||det(A,B)===0);
      do{mTrue=randInt(-3,3);nTrue=randInt(-3,3)}while(mTrue===0&&nTrue===0);
      target={x:mTrue*A.x+nTrue*B.x,y:mTrue*A.y+nTrue*B.y};
    }

    // ---------- KaTeX helpers ----------
    function renderLatex(el, tex){ if(window.katex){katex.render(tex, el, {throwOnError:false});} else {el.textContent=tex} }
    const vecTex=(name,v)=>`\vec ${name} = \langle ${v.x},\,${v.y}\rangle`;
    function problemTex(){
      return `Given\; ${vecTex('a',A)},\; ${vecTex('b',B)}\; \text{find integers } m,n \text{ such that } m\,\vec a+n\,\vec b = \langle ${target.x},\,${target.y}\rangle.`;
    }
    function solutionTex(){
      const lhs=`(${mTrue})\,${vecTex('a',A)}+(${nTrue})\,${vecTex('b',B)}`;
      const p1=`=\; \langle ${mTrue*A.x},${mTrue*A.y}\rangle + \langle ${nTrue*B.x},${nTrue*B.y}\rangle`;
      const p2=`=\; \langle ${target.x},${target.y}\rangle`;
      return `m=${mTrue},\; n=${nTrue}\quad\Rightarrow\quad ${lhs}\; ${p1}\; ${p2}`;
    }

    // ---------- SVG helpers ----------
    function mk(n){return document.createElementNS('http://www.w3.org/2000/svg',n)}
    function gridAxes(svg,cx,cy,w,h,s){
      // grid
      for(let x=0;x<=w;x+=s){const L=mk('line');L.setAttribute('x1',x);L.setAttribute('y1',0);L.setAttribute('x2',x);L.setAttribute('y2',h);L.setAttribute('stroke','#e2e8f0');L.setAttribute('stroke-width','1');svg.appendChild(L)}
      for(let y=0;y<=h;y+=s){const L=mk('line');L.setAttribute('x1',0);L.setAttribute('y1',y);L.setAttribute('x2',w);L.setAttribute('y2',y);L.setAttribute('stroke','#e2e8f0');L.setAttribute('stroke-width','1');svg.appendChild(L)}
      // axes
      const axX=mk('line'); axX.setAttribute('x1',0); axX.setAttribute('y1',cy); axX.setAttribute('x2',w); axX.setAttribute('y2',cy); axX.setAttribute('stroke','#94a3b8'); axX.setAttribute('stroke-width','1.5'); svg.appendChild(axX);
      const axY=mk('line'); axY.setAttribute('x1',cx); axY.setAttribute('y1',0); axY.setAttribute('x2',cx); axY.setAttribute('y2',h); axY.setAttribute('stroke','#94a3b8'); axY.setAttribute('stroke-width','1.5'); svg.appendChild(axY);
      // origin dot
      const O=mk('circle'); O.setAttribute('cx',cx); O.setAttribute('cy',cy); O.setAttribute('r','2.5'); O.setAttribute('fill','#64748b'); svg.appendChild(O);
    }
    function ensureMarker(svg,id,color){ if(svg.querySelector(`#${id}`)) return id; const defs=svg.querySelector('defs')||svg.insertBefore(mk('defs'), svg.firstChild); const m=mk('marker'); m.setAttribute('id',id); m.setAttribute('markerWidth','10'); m.setAttribute('markerHeight','10'); m.setAttribute('refX','8'); m.setAttribute('refY','3'); m.setAttribute('orient','auto'); const p=mk('path'); p.setAttribute('d','M0,0 L9,3 L0,6 Z'); p.setAttribute('fill',color); m.appendChild(p); defs.appendChild(m); return id; }

    // fixed-scale boards (A,B,Main)
    function drawFixedBoard(svg, vecs={}){
      const w=+svg.viewBox.baseVal.width, h=+svg.viewBox.baseVal.height; svg.innerHTML='';
      const s=20, cx=w/2, cy=h/2; gridAxes(svg,cx,cy,w,h,s);
      const toPx=(pt)=>({x:cx+s*pt.x, y:cy-s*pt.y});
      const arrow=(p1,p2,color,name)=>{ const id=ensureMarker(svg,`ah-${name}`,color); const L=mk('line'); L.setAttribute('x1',p1.x); L.setAttribute('y1',p1.y); L.setAttribute('x2',p2.x); L.setAttribute('y2',p2.y); L.setAttribute('stroke',color); L.setAttribute('stroke-width','3'); L.setAttribute('marker-end',`url(#${id})`); svg.appendChild(L); };
      const dot=(pt,color,r=5)=>{ const C=mk('circle'); C.setAttribute('cx',pt.x); C.setAttribute('cy',pt.y); C.setAttribute('r',r); C.setAttribute('fill',color); svg.appendChild(C); };
      const label=(pt,text)=>{ const T=mk('text'); T.setAttribute('x',pt.x+6); T.setAttribute('y',pt.y-6); T.setAttribute('fill','#0f172a'); T.setAttribute('font-size','12'); T.textContent=text; svg.appendChild(T); };
      const css=getComputedStyle(document.documentElement);
      if(vecs.A){ arrow(toPx({x:0,y:0}), toPx(vecs.A), css.getPropertyValue('--a'), 'a'); label(toPx(vecs.A),'a'); }
      if(vecs.B){ arrow(toPx({x:0,y:0}), toPx(vecs.B), css.getPropertyValue('--b'), 'b'); label(toPx(vecs.B),'b'); }
      if(vecs.target){ dot(toPx(vecs.target), css.getPropertyValue('--target')); label(toPx(vecs.target), `(${vecs.target.x}, ${vecs.target.y})`); }
    }

    // auto-fit board (Solution)
    function drawSolutionBoard(svg){
      const w=+svg.viewBox.baseVal.width, h=+svg.viewBox.baseVal.height; svg.innerHTML='';
      // collect points to fit
      const O={x:0,y:0};
      const Astep={x:mTrue*A.x, y:mTrue*A.y};
      const Bstep={x:nTrue*B.x, y:nTrue*B.y};
      const P2={x:Astep.x+Bstep.x, y:Astep.y+Bstep.y}; // equals target
      const pts=[O,A,B,target,Astep,P2];
      // bounds with padding
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(const p of pts){ minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x); minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y); }
      const pad=1.5; // extra units around
      minX-=pad; maxX+=pad; minY-=pad; maxY+=pad;
      // scale to fit
      const rangeX=maxX-minX || 1, rangeY=maxY-minY || 1;
      const s=Math.min((w-40)/rangeX, (h-40)/rangeY); // 20px padding each side
      const cx = (0 - minX) * s + 20; // pixel where x=0 lands
      const cy = (maxY - 0) * s + 20; // pixel where y=0 lands (invert y)

      // grid (snap to integer ticks around bounds)
      const xStart=Math.ceil(minX), xEnd=Math.floor(maxX);
      const yStart=Math.ceil(minY), yEnd=Math.floor(maxY);
      for(let x=xStart; x<=xEnd; x++){ const L=mk('line'); L.setAttribute('x1', (x-minX)*s+20); L.setAttribute('y1', 20); L.setAttribute('x2', (x-minX)*s+20); L.setAttribute('y2', h-20); L.setAttribute('stroke','#e2e8f0'); L.setAttribute('stroke-width','1'); svg.appendChild(L);} 
      for(let y=yStart; y<=yEnd; y++){ const L=mk('line'); L.setAttribute('x1', 20); L.setAttribute('y1', (maxY-y)*s+20); L.setAttribute('x2', w-20); L.setAttribute('y2', (maxY-y)*s+20); L.setAttribute('stroke','#e2e8f0'); L.setAttribute('stroke-width','1'); svg.appendChild(L);} 
      // axes
      const axX=mk('line'); axX.setAttribute('x1',20); axX.setAttribute('y1',cy); axX.setAttribute('x2',w-20); axX.setAttribute('y2',cy); axX.setAttribute('stroke','#94a3b8'); axX.setAttribute('stroke-width','1.5'); svg.appendChild(axX);
      const axY=mk('line'); axY.setAttribute('x1',cx); axY.setAttribute('y1',20); axY.setAttribute('x2',cx); axY.setAttribute('y2',h-20); axY.setAttribute('stroke','#94a3b8'); axY.setAttribute('stroke-width','1.5'); svg.appendChild(axY);
      const ODot=mk('circle'); ODot.setAttribute('cx',cx); ODot.setAttribute('cy',cy); ODot.setAttribute('r','2.5'); ODot.setAttribute('fill','#64748b'); svg.appendChild(ODot);

      const toPx=(pt)=>({x:(pt.x-minX)*s+20, y:(maxY-pt.y)*s+20});
      const css=getComputedStyle(document.documentElement);
      const arrow=(p1,p2,color,name)=>{ const id=ensureMarker(svg,`ah-${name}`,color); const L=mk('line'); L.setAttribute('x1',p1.x); L.setAttribute('y1',p1.y); L.setAttribute('x2',p2.x); L.setAttribute('y2',p2.y); L.setAttribute('stroke',color); L.setAttribute('stroke-width','3'); L.setAttribute('marker-end',`url(#${id})`); svg.appendChild(L); };
      const dot=(pt,color,r=5)=>{ const C=mk('circle'); C.setAttribute('cx',pt.x); C.setAttribute('cy',pt.y); C.setAttribute('r',r); C.setAttribute('fill',color); svg.appendChild(C); };

      // draw base vectors, target, components and resultant
      arrow(toPx({x:0,y:0}), toPx(A), css.getPropertyValue('--a'), 'a');
      arrow(toPx({x:0,y:0}), toPx(B), css.getPropertyValue('--b'), 'b');
      dot(toPx(target), css.getPropertyValue('--target'));
      // components tip-to-tail
      const Aend = toPx({x:Astep.x, y:Astep.y});
      const Bend = toPx({x:P2.x, y:P2.y});
      arrow(toPx({x:0,y:0}), Aend, css.getPropertyValue('--combo'), 'c1');
      arrow(Aend, Bend, css.getPropertyValue('--combo'), 'c2');
      // resultant
      arrow(toPx({x:0,y:0}), toPx(P2), css.getPropertyValue('--combo'), 'c');
    }

    // ---------- Orchestration ----------
    function drawAllFixed(){
      drawFixedBoard(document.getElementById('boardA'), {A});
      drawFixedBoard(document.getElementById('boardB'), {B});
      drawFixedBoard(document.getElementById('boardMain'), {A,B,target});
    }

    function mount(){
      newInstance();
      renderLatex(document.getElementById('problem'), problemTex());
      drawAllFixed();
      const btn=document.getElementById('showBtn');
      let shown=false;
      btn.addEventListener('click', ()=>{
        shown=!shown;
        btn.textContent = shown? 'Hide Solution' : 'Show Solution';
        document.getElementById('solutionWrap').style.display = shown? 'block':'none';
        if(shown){
          drawSolutionBoard(document.getElementById('boardSolution'));
          renderLatex(document.getElementById('solution'), solutionTex());
        }
      });

      // self-checks
      try{
        console.assert(det({x:1,y:0},{x:0,y:1})!==0, 'det should be nonzero for basis');
        const t={x:mTrue*A.x+nTrue*B.x, y:mTrue*A.y+nTrue*B.y};
        console.assert(t.x===target.x && t.y===target.y, 'target construction must be exact');
      }catch(e){ console.warn('Self-check failed:', e); }
    }

    document.addEventListener('DOMContentLoaded', async ()=>{
      try{ await waitFor(()=>window.katex && window.renderMathInElement); window.renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}], throwOnError:false}); }catch(_){/* graceful */}
      mount();
    });
  </script>
</body>
</html>
