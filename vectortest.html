<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vector Target — Integer Linear Combinations</title>
  <!-- KaTeX (explicit render) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#0f172a; --muted:#475569; --soft:#f8fafc; --card:#ffffff; --border:#e2e8f0;
      --u:#1d4ed8; --v:#059669; --stepA:#ef4444; --stepB:#f59e0b; --result:#7c3aed;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font:16px/1.45 ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; color:var(--ink); background:var(--bg);} 
    .wrap{max-width:1100px; margin:28px auto; padding:0 16px;}
    header{text-align:center; margin-bottom:18px}
    h1{font-size:clamp(22px,3vw,32px); margin:0 0 8px 0}
    .subtitle{color:var(--muted)}
    .row{display:flex; gap:16px; flex-wrap:wrap}
    .card{background:var(--card); border:1px solid var(--border); border-radius:14px; padding:14px}
    .title{font-weight:600; color:var(--muted); margin:0 0 8px 0}
    .katex{font-size:1.05rem}
    .btn{appearance:none; border:1px solid var(--border); background:var(--soft); color:var(--ink); padding:10px 12px; border-radius:10px; cursor:pointer}
    .btn:hover{filter:brightness(0.98)}
    .boards{display:grid; grid-template-columns:repeat(2,1fr); gap:16px; margin-top:8px}
    @media (max-width: 960px){ .boards{grid-template-columns:1fr} }
    svg.board{width:100%; height:340px; background:#fff; border:1px solid var(--border); border-radius:12px}
    .label{margin-top:8px; text-align:center}
    .note{margin-top:8px; color:var(--muted); font-size:14px}
    .katex .uColor { color: var(--u); }
    .katex .vColor { color: var(--v); }
  </style>

  <style id="theme-override">
  /* --- palette like the Shopping Math doc (keeps your u/v/result colors) --- */
  :root{
    --bg:#fafafa;
    --card:#ffffff; 
    --muted:#4b5563;
    --text:#111827;
    --accent:#1d4ed8;       /* unused here but useful if you add primary buttons */
    --accent-weak:#e0e7ff;  /* ditto */
    --ok:#15803d;
    --error:#b91c1c;
    --border:#e5e7eb;
  }

  /* --- global type & page frame (serif, 14px, centered wrap) --- */
  html,body{
    margin:0; padding:0;
    background:var(--bg);
    color:var(--text);
    font-family:"Latin Modern Roman","Computer Modern Serif",Georgia,Cambria,"Times New Roman",Times,serif;
    font-size:14px;
    line-height:1.45;
  }
  .wrap{ max-width:900px; margin:0 auto; padding:20px; }

  /* --- headings like the sample --- */
  h1,h2{
    line-height:1.2; margin:0 0 8px;
    font-family:"Latin Modern Roman","Computer Modern Serif",Georgia,serif;
    font-weight:400;
  }
  h1{ font-size:1.6rem; text-align:center; margin-bottom:4px; }
  .subtitle{ display:block; text-align:center; color:var(--muted); }
  /* Your page doesn’t use <h2>, but this harmonizes any .title you have: */
  .title{ font-size:1.1rem; margin:0 0 8px; color:var(--muted); font-weight:600; }

  /* --- cards / panels --- */
  .card{
    background:var(--card);
    box-shadow:0 1px 4px rgba(0,0,0,.05);
    border-radius:8px;
    padding:12px;
    border:1px solid var(--border);
    margin-top:10px;
  }

  /* --- buttons like the sample (simple, neutral) --- */
  .btn{
    border:1px solid var(--border);
    border-radius:6px;
    padding:6px 10px;
    background:#ffffff;
    color:var(--text);
    cursor:pointer;
    transition:background .15s ease;
    font-family:inherit;
    font-size:13px;
  }
  .btn:hover{ background:#f9fafb; }

  /* --- small text styles to match feel --- */
  .subtitle{ color:var(--muted); }
  .note{ color:var(--muted); font-size:12px; }

  /* --- math sizing (keeps KaTeX, just slightly smaller to match 14px base) --- */
  .katex { font-size: 1rem; }
</style>

  
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Vector Target</h1>
      <div class="note">Math with Mr. Merrick</div>
      <div id="subtitle" class="subtitle katex"></div>
    </header>


    <!-- Problem statement (ONLY the target point) + Show Solution button -->
    <div class="row" style="align-items:center; justify-content:space-between">
      <div id="problem" class="katex"></div>
      <div style="display:flex; gap:8px">
        <button id="newBtn" class="btn">New Problem</button>
        <button id="showBtn" class="btn">Show Solution</button>
      </div>
    </div>


    <!-- Two separate boards for u and v; math labels BELOW each plot -->
    <div class="boards">
      <div class="card">
        <svg id="boardU" class="board" viewBox="0 0 420 340"></svg>
        <div id="labelU" class="label katex"></div>
      </div>
      <div class="card">
        <svg id="boardV" class="board" viewBox="0 0 420 340"></svg>
        <div id="labelV" class="label katex"></div>
      </div>
    </div>

    <!-- Solution board appears at the bottom when toggled; auto-fits to content -->
    <div id="solutionWrap" class="card" style="display:none; margin-top:16px">
      <p class="title">Solution (visual for a·u + b·v only)</p>
      <svg id="boardSolution" class="board" viewBox="0 0 1000 420"></svg>
      <div id="solution" class="katex" style="margin-top:10px"></div>
    </div>

    <p class="note">Click “Show Solution” to reveal one valid integer combination and a tip‑to‑tail visualization on a separate, auto‑sized board at the bottom.</p>
  </div>

  <script>
     // ====== KaTeX helpers ======
    function waitFor(cond,{interval=50,timeout=8000}={}){return new Promise((res,rej)=>{const t=Date.now();(function chk(){if(cond())return res();if(Date.now()-t>timeout)return rej(new Error('Timeout'));setTimeout(chk,interval)})()})}
    function kx(el, tex){
      if (window.katex) {
        window.katex.render(tex, el, { throwOnError: false, trust: true });
      } else {
        el.textContent = tex;
      }
    }

    // ====== Random instance generation ======
    const R=(a,b)=>Math.floor(Math.random()*(b-a+1))+a; // inclusive
    const det=(u,v)=>u.x*v.y-u.y*v.x;

    let U,V,target,aTrue,bTrue;

    function newInstance(){
      do{U={x:R(-5,5),y:R(-5,5)}}while(U.x===0&&U.y===0);
      do{V={x:R(-5,5),y:R(-5,5)}}while((V.x===0&&V.y===0)||det(U,V)===0);
      do{aTrue=R(-3,3);bTrue=R(-3,3)}while(aTrue===0&&bTrue===0);
      target={x:aTrue*U.x+bTrue*V.x,y:aTrue*U.y+bTrue*V.y};
    }

    // ====== TeX generators (colored vectors + a_n, b) ======
    const vecTex = (name, v) => {
      const cls = name === 'u' ? 'uColor' : 'vColor';
      const sym = name === 'u' ? '\\vec{u}' : '\\vec{v}';
      // Use \htmlClass to color the symbol to match the SVG vector
      return `\\htmlClass{${cls}}{${sym}}=\\langle ${v.x},\\,${v.y}\\rangle`;
    };
    
    const targetTex = () =>
      `\\text{Target: }\\langle ${target.x},\\,${target.y}\\rangle`;
    
    const subtitleTex = () =>
      `\\text{Find integers } a,b \\text{ such that } a\\,\\htmlClass{uColor}{\\vec{u}}+b\\,\\htmlClass{vColor}{\\vec{v}} \\text{ hits the target.}`;
    
    const solutionTex = () => {
      const lhs = `(${aTrue})\\,\\htmlClass{uColor}{\\vec{u}}+(${bTrue})\\,\\htmlClass{vColor}{\\vec{v}}`;
      const p1  = `=\\; \\langle ${aTrue*U.x},${aTrue*U.y}\\rangle + \\langle ${bTrue*V.x},${bTrue*V.y}\\rangle`;
      const p2  = `=\\; \\langle ${target.x},${target.y}\\rangle`;
      return `a=${aTrue},\\; b=${bTrue}\\quad\\Rightarrow\\quad ${lhs}\\; ${p1}\\; ${p2}`;
    };



    // ====== SVG utilities ======
    const mk=n=>document.createElementNS('http://www.w3.org/2000/svg',n);
    // Replace your entire gridAxes() with this version
    function gridAxes(svg, cx, cy, w, h, s) {
      // vertical lines: ... cx-2s, cx-s, cx, cx+s, cx+2s ...
      const mk = n => document.createElementNS('http://www.w3.org/2000/svg', n);
      const addLine = (x1,y1,x2,y2,stroke='#e2e8f0',sw=1) => {
        const L = mk('line');
        L.setAttribute('x1', x1); L.setAttribute('y1', y1);
        L.setAttribute('x2', x2); L.setAttribute('y2', y2);
        L.setAttribute('stroke', stroke);
        L.setAttribute('stroke-width', sw);
        L.setAttribute('shape-rendering', 'crispEdges');
        svg.appendChild(L);
      };
    
      // Draw vertical grid lines, centered on cx
      for (let x = cx; x <= w; x += s) addLine(x, 0, x, h);
      for (let x = cx - s; x >= 0; x -= s) addLine(x, 0, x, h);
    
      // Draw horizontal grid lines, centered on cy
      for (let y = cy; y <= h; y += s) addLine(0, y, w, y);
      for (let y = cy - s; y >= 0; y -= s) addLine(0, y, w, y);
    
      // Axes
      addLine(0, cy, w, cy, '#94a3b8', 1.5);  // x-axis
      addLine(cx, 0, cx, h, '#94a3b8', 1.5);  // y-axis
    
      // Origin dot
      const O = mk('circle');
      O.setAttribute('cx', cx); O.setAttribute('cy', cy);
      O.setAttribute('r', '2.5'); O.setAttribute('fill', '#64748b');
      svg.appendChild(O);
    }

    function ensureMarker(svg,id,color){ if(svg.querySelector(`#${id}`)) return id; const defs=svg.querySelector('defs')||svg.insertBefore(mk('defs'), svg.firstChild); const m=mk('marker'); m.setAttribute('id',id); m.setAttribute('markerWidth','10'); m.setAttribute('markerHeight','10'); m.setAttribute('refX','8'); m.setAttribute('refY','3'); m.setAttribute('orient','auto'); const p=mk('path'); p.setAttribute('d','M0,0 L9,3 L0,6 Z'); p.setAttribute('fill',color); m.appendChild(p); defs.appendChild(m); return id; }

    function drawVectorBoard(svg, vec, colorVar){
      const w=+svg.viewBox.baseVal.width, h=+svg.viewBox.baseVal.height; svg.innerHTML='';
      const s=20, cx=w/2, cy=h/2; // 1 unit = 20px; gridlines every 1 unit
      gridAxes(svg,cx,cy,w,h,s);
      const toPx=pt=>({x:cx+s*pt.x, y:cy-s*pt.y});
      const css=getComputedStyle(document.documentElement);
      const color = css.getPropertyValue(colorVar);
      const id = ensureMarker(svg, `ah-${colorVar.slice(2)}`, color);
      const p1=toPx({x:0,y:0}), p2=toPx(vec);
      const L=mk('line'); L.setAttribute('x1',p1.x); L.setAttribute('y1',p1.y); L.setAttribute('x2',p2.x); L.setAttribute('y2',p2.y); L.setAttribute('stroke',color); L.setAttribute('stroke-width','3'); L.setAttribute('marker-end',`url(#${id})`); svg.appendChild(L);
    }

    function drawSolutionBoard(svg){
      const w=+svg.viewBox.baseVal.width, h=+svg.viewBox.baseVal.height; svg.innerHTML='';
      const O={x:0,y:0};
      const Astep={x:aTrue*U.x, y:aTrue*U.y};
      const Bstep={x:bTrue*V.x, y:bTrue*V.y};
      const P2={x:Astep.x+Bstep.x, y:Astep.y+Bstep.y}; // equals target
      const pts=[O,Astep,P2];
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(const p of pts){ minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x); minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y); }
      const pad=1.5; minX-=pad; maxX+=pad; minY-=pad; maxY+=pad;
      const rangeX=maxX-minX || 1, rangeY=maxY-minY || 1;
      const s=Math.min((w-40)/rangeX, (h-40)/rangeY);
      const cx=(0-minX)*s+20, cy=(maxY-0)*s+20;
      const toPx=pt=>({x:(pt.x-minX)*s+20, y:(maxY-pt.y)*s+20});
      // grid (1-unit)
      const xStart=Math.ceil(minX), xEnd=Math.floor(maxX);
      const yStart=Math.ceil(minY), yEnd=Math.floor(maxY);
      for(let x=xStart;x<=xEnd;x++){const L=mk('line');L.setAttribute('x1',(x-minX)*s+20);L.setAttribute('y1',20);L.setAttribute('x2',(x-minX)*s+20);L.setAttribute('y2',h-20);L.setAttribute('stroke','#e2e8f0');L.setAttribute('stroke-width','1');svg.appendChild(L)}
      for(let y=yStart;y<=yEnd;y++){const L=mk('line');L.setAttribute('x1',20);L.setAttribute('y1',(maxY-y)*s+20);L.setAttribute('x2',w-20);L.setAttribute('y2',(maxY-y)*s+20);L.setAttribute('stroke','#e2e8f0');L.setAttribute('stroke-width','1');svg.appendChild(L)}
      // axes + origin dot
      const axX=mk('line'); axX.setAttribute('x1',20); axX.setAttribute('y1',cy); axX.setAttribute('x2',w-20); axX.setAttribute('y2',cy); axX.setAttribute('stroke','#94a3b8'); axX.setAttribute('stroke-width','1.5'); svg.appendChild(axX);
      const axY=mk('line'); axY.setAttribute('x1',cx); axY.setAttribute('y1',20); axY.setAttribute('x2',cx); axY.setAttribute('y2',h-20); axY.setAttribute('stroke','#94a3b8'); axY.setAttribute('stroke-width','1.5'); svg.appendChild(axY);
      const ODot=mk('circle'); ODot.setAttribute('cx',cx); ODot.setAttribute('cy',cy); ODot.setAttribute('r','2.5'); ODot.setAttribute('fill','#64748b'); svg.appendChild(ODot);
      // draw only the linear combination visually: a*u then + b*v, then resultant
      const css=getComputedStyle(document.documentElement);
      const arrow=(p1,p2,color,name)=>{ const id=ensureMarker(svg,`ah-${name}`,color); const L=mk('line'); L.setAttribute('x1',p1.x); L.setAttribute('y1',p1.y); L.setAttribute('x2',p2.x); L.setAttribute('y2',p2.y); L.setAttribute('stroke',color); L.setAttribute('stroke-width','3'); L.setAttribute('marker-end',`url(#${id})`); svg.appendChild(L); };
      const Aend=toPx(Astep), Bend=toPx(P2);
      arrow(toPx({x:0,y:0}), Aend, css.getPropertyValue('--stepA'), 'stepA'); // a*U
      arrow(Aend, Bend, css.getPropertyValue('--stepB'), 'stepB');             // + b*V
      arrow(toPx({x:0,y:0}), Bend, css.getPropertyValue('--result'), 'result'); // resultant
    }

    // ====== Mount ======
    async function mount(){
      await waitFor(()=>window.katex);
      newInstance();
      // Render math: subtitle + target + labels under plots
      kx(document.getElementById('subtitle'), subtitleTex());
      kx(document.getElementById('problem'), targetTex());
      kx(document.getElementById('labelU'), vecTex('u', U));
      kx(document.getElementById('labelV'), vecTex('v', V));
      // Draw vector boards with 1-unit gridlines
      drawVectorBoard(document.getElementById('boardU'), U, '--u');
      drawVectorBoard(document.getElementById('boardV'), V, '--v');
      // Button behavior
      const btn=document.getElementById('showBtn');
      let shown=false;
      btn.addEventListener('click', ()=>{
        shown=!shown; btn.textContent = shown? 'Hide Solution' : 'Show Solution';
        const wrap=document.getElementById('solutionWrap'); wrap.style.display = shown? 'block':'none';
        if(shown){ drawSolutionBoard(document.getElementById('boardSolution')); kx(document.getElementById('solution'), solutionTex()); }
      });
      // New Problem button behavior
      const newBtn = document.getElementById('newBtn');
      newBtn.addEventListener('click', ()=>{
        newInstance();
        // re-render math labels
        kx(document.getElementById('subtitle'), subtitleTex());
        kx(document.getElementById('problem'), targetTex());
        kx(document.getElementById('labelU'), vecTex('u', U));
        kx(document.getElementById('labelV'), vecTex('v', V));
        // redraw boards
        drawVectorBoard(document.getElementById('boardU'), U, '--u');
        drawVectorBoard(document.getElementById('boardV'), V, '--v');
        // reset solution area
        document.getElementById('solutionWrap').style.display = 'none';
        document.getElementById('showBtn').textContent = 'Show Solution';
      });
    }

    document.addEventListener('DOMContentLoaded', mount);
  </script>
</body>
</html>
