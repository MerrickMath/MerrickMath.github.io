<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Graph Blitz</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0e1730; --ink:#e6ebff; --accent:#7aa2f7;
    --ccyan:#009999; --cgreen:#009900; --cblue:#0000cc; --cmagenta:#ff00ff; --corange:#ff8000; --cred:#ff0000; --cblack:#111111;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif;
    color:var(--ink); background:radial-gradient(1200px 900px at 20% 0%,#17203f 0%,#0b1220 60%) fixed;
  }
  header{
    padding:20px 16px; display:flex; gap:12px; align-items:center; justify-content:space-between;
    max-width:1100px; margin:0 auto;
  }
  h1{margin:0; font-size:20px; letter-spacing:.3px; font-weight:700}
  .controls{display:flex; gap:10px; flex-wrap:wrap}
  button{
    cursor:pointer; border:1px solid #2a386b; background:#131d3a; color:var(--ink);
    padding:10px 14px; border-radius:12px; font-weight:600; transition:.15s transform ease,.15s background-color ease,.15s border-color ease;
  }
  button:hover{transform:translateY(-1px); background:#17244a; border-color:#3a4a8a}
  button.secondary{background:#10172b; border-color:#22305e}
  main{max-width:1100px; margin:0 auto; padding:0 16px 28px}
  .card{
    position:relative; background:#0c1329; border:1px solid #222d56; border-radius:20px; padding:20px;
    box-shadow:0 10px 35px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03);
  }
  .stage{display:grid; grid-template-columns:1fr 340px; gap:18px}
  @media (max-width:1020px){ .stage{grid-template-columns:1fr} }
  .plotWrap{
    background:#f8faff; border-radius:16px; padding:12px; min-height:420px; overflow:hidden; position:relative;
  }
  .plotWrap svg{width:100%; height:420px; display:block; background:#fff; border-radius:12px}
  .legend{
    display:grid; gap:8px; grid-template-columns:repeat(2,minmax(0,1fr));
    background:var(--panel); border:1px solid #1b2550; border-radius:14px; padding:12px;
    align-self:start;
  }
  .legend h3{margin:0 0 6px; grid-column:1/-1; font-size:14px; color:#cfd8ff; opacity:.9}
  .pill{display:flex; gap:8px; align-items:center; padding:8px 10px; background:#0d1631; border:1px solid #1b2550; border-radius:12px}
  .dot{width:12px; height:12px; border-radius:50%}
  .eq{font-family:ui-monospace, "SF Mono", Menlo, Consolas, monospace; font-size:12px; color:#dfe6ff}
  .edges{
    margin-top:18px; display:grid; grid-template-columns:repeat(2,1fr); gap:10px;
  }
  .edge{
    padding:10px 12px; border-radius:12px; background:#10183a; border:1px dashed #314078;
    display:flex; align-items:center; justify-content:center; min-height:42px; text-align:center;
    font-weight:700; letter-spacing:.2px;
  }
  .edge .eq{font-weight:800}
  .edge.correct{border-style:solid; border-color:#38b263; box-shadow:0 0 0 3px rgba(56,178,99,.18) inset}
  .edge.wrong{opacity:.55}
  .tiny{opacity:.75; font-size:12px}
  .toast{
    position:fixed; z-index:50; right:14px; bottom:14px; padding:10px 12px; border-radius:10px;
    background:#0e1a3b; border:1px solid #2b3a72; color:#cfe1ff; font-weight:600; box-shadow:0 10px 30px rgba(0,0,0,.4);
    opacity:0; transform:translateY(10px); transition:.2s opacity ease,.2s transform ease;
  }
  .toast.show{opacity:1; transform:none}
  footer{opacity:.7; text-align:center; font-size:12px; padding:10px}
</style>
</head>
<body>
<header>
  <h1>Graph Blitz</h1>
  <div class="controls">
    <button id="btn-new">New card</button>
    <button id="btn-solution" class="secondary">Show solution</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="stage">
      <div class="plotWrap">
        <svg id="plot" viewBox="0 0 900 520" preserveAspectRatio="xMidYMid meet" aria-label="Graph plot area"></svg>
      </div>
      <aside class="legend" id="legend">
        <h3>Families on this card</h3>
        <!-- pills inserted here -->
      </aside>
    </div>

    <div class="edges" id="edges">
      <!-- 4 edges inserted here -->
    </div>

    <div style="margin-top:12px" class="tiny">Rule: If any edge is a correctly colored equation, it’s the answer. Otherwise, pick the single edge whose <em>color and equation</em> both come from families <strong>absent</strong> from the plot.</div>
  </div>
</main>

<div class="toast" id="toast">New card generated</div>
<footer>Host this file with GitHub Pages to let students play online.</footer>

<script>
/* ---------- Data & helpers ---------- */
const COLORS = {
  ccyan:    getCSS('--ccyan'),
  cgreen:   getCSS('--cgreen'),
  black:    getCSS('--cblack'),
  cblue:    getCSS('--cblue'),
  cmagenta: getCSS('--cmagenta'),
  corange:  getCSS('--corange'),
  cred:     getCSS('--cred'),
};

const FAMILIES = [
  { key:'lin',   name:'Linear',       eq:'y = x',         color:'ccyan'   },
  { key:'quad',  name:'Quadratic',    eq:'y = x^2',       color:'cgreen'  },
  { key:'sin',   name:'Sinusoidal',   eq:'y = sin(x)',    color:'black'   },
  { key:'recip', name:'Reciprocal',   eq:'y = 1/x',       color:'cblue'   },
  { key:'exp',   name:'Exponential',  eq:'y = e^x',       color:'cmagenta'},
  { key:'rad',   name:'Radical',      eq:'y = sqrt(x)',   color:'corange' },
  { key:'cub',   name:'Cubic',        eq:'y = x^3',       color:'cred'    },
];
const byKey = Object.fromEntries(FAMILIES.map(f => [f.key, f]));
const colorToKey = Object.fromEntries(FAMILIES.map(f => [f.color, f.key]));
const eqToKey = Object.fromEntries(FAMILIES.map(f => [f.eq, f.key]));
const EQS = FAMILIES.map(f => f.eq);
const KEYS = FAMILIES.map(f => f.key);

function getCSS(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)] }
function sample(arr, k){
  const copy=[...arr]; const res=[];
  for(let i=0;i<k;i++){ const j=Math.floor(Math.random()*copy.length); res.push(copy.splice(j,1)[0]); }
  return res;
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()* (i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* ---------- Card generator (always-solvable) ---------- */
function makeCard(){
  const present4 = sample(KEYS, 4).sort();
  const absent = KEYS.filter(k => !present4.includes(k));

  // Decide card type: 50% match, 50% absent
  const matchType = Math.random() < 0.5;

  let edges = []; // list of {color, eq}
  if (matchType){
    // Exactly ONE correctly colored edge
    const matchKey = randChoice(present4);
    edges.push({ color: byKey[matchKey].color, eq: byKey[matchKey].eq });
    const others = present4.filter(k => k !== matchKey);
    for (const colKey of others){
      const color = byKey[colKey].color;
      // pick an equation from a different family (can be present or absent), ensure mismatch
      const choices = KEYS.filter(k => k !== colKey);
      const eqKey = randChoice(choices);
      edges.push({ color, eq: byKey[eqKey].eq });
    }
  } else {
    // ABSENT: zero color-correct edges.
    // Create exactly one edge whose color & equation are from two different absent families.
    const [aColorKey, aEqKey] = sample(absent, 2);
    edges.push({ color: byKey[aColorKey].color, eq: byKey[aEqKey].eq });
    // Other three: colors from present; eq from present but not same as the color family
    for (let i=0;i<3;i++){
      const colKey = randChoice(present4);
      const color = byKey[colKey].color;
      const choices = present4.filter(k => k !== colKey);
      const eqKey = randChoice(choices);
      edges.push({ color, eq: byKey[eqKey].eq });
    }
  }

  // Verify constraints
  const isCorrectPair = (edge)=> colorToKey[edge.color] === eqToKey[edge.eq];
  const correctCount = edges.filter(isCorrectPair).length;
  if (matchType){
    if (correctCount !== 1){
      return makeCard(); // retry if unlucky
    }
  } else {
    if (correctCount !== 0){
      return makeCard(); // retry
    }
    const isFullyAbsent = (edge)=>{
      const ck = colorToKey[edge.color], ek = eqToKey[edge.eq];
      return !present4.includes(ck) && !present4.includes(ek);
    };
    const fullyAbsentCount = edges.filter(isFullyAbsent).length;
    if (fullyAbsentCount !== 1){
      return makeCard(); // retry
    }
  }

  // Randomize assignment to positions
  edges = shuffle(edges);

  // Compute the unique answer index
  let answerIdx = -1;
  if (correctCount === 1){
    answerIdx = edges.findIndex(isCorrectPair);
  } else {
    // no correct colors; choose the fully-absent one
    const isFullyAbsent = (edge)=>{
      const ck = colorToKey[edge.color], ek = eqToKey[edge.eq];
      return !present4.includes(ck) && !present4.includes(ek);
    };
    answerIdx = edges.findIndex(isFullyAbsent);
  }

  return { present4, edges, answerIdx };
}

/* ---------- Plotting (SVG) ---------- */
// We draw in a scaled coordinate system: x ∈ [-3,3], y ∈ [-3,3]
const PLOT = document.getElementById('plot');
const W = 900, H = 520;
const PAD = 40;
const XMIN=-3, XMAX=3, YMIN=-3, YMAX=3;

function scaleX(x){ return PAD + (x - XMIN) / (XMAX - XMIN) * (W - 2*PAD); }
function scaleY(y){ return H - PAD - (y - YMIN) / (YMAX - YMIN) * (H - 2*PAD); }

function mk(tag, attrs={}, children=[]){
  const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k,v] of Object.entries(attrs)){ el.setAttribute(k, v); }
  for (const ch of children) el.appendChild(ch);
  return el;
}

function axes(){
  const g = mk('g', { 'stroke': '#555', 'stroke-width':'1' });
  // axes lines
  const x0 = scaleY(0), y0 = scaleX(0);
  g.appendChild(mk('line', { x1: scaleX(XMIN), y1: x0, x2: scaleX(XMAX), y2: x0, stroke:'#888' }));
  g.appendChild(mk('line', { x1: y0, y1: scaleY(YMIN), x2: y0, y2: scaleY(YMAX), stroke:'#888' }));
  // ticks (optional light)
  for (let t=-3; t<=3; t++){
    const tx = scaleX(t), ty = scaleY(t);
    g.appendChild(mk('line', { x1: tx, y1: x0-4, x2: tx, y2: x0+4, stroke:'#bbb' }));
    g.appendChild(mk('line', { x1: y0-4, y1: ty, x2: y0+4, y2: ty, stroke:'#bbb' }));
  }
  return g;
}

function pathFor(f, options={}){
  const { color='#000', width=3 } = options;
  const N = 700;
  let d = '';
  function moveTo(x,y){ d += (d ? ' L ' : 'M ') + scaleX(x).toFixed(2) + ' ' + scaleY(y).toFixed(2); }
  function lineTo(x,y){ d += ' L ' + scaleX(x).toFixed(2) + ' ' + scaleY(y).toFixed(2); }

  // split into safe segments for discontinuities
  const segments = f.segments;
  for (const seg of segments){
    const [a,b] = seg;
    let first=true;
    for (let i=0;i<=N;i++){
      const x = a + (b-a)*i/N;
      let y = f.fn(x);
      if (!isFinite(y)) { first=true; continue; }
      y = Math.max(YMIN-1, Math.min(YMAX+1, y));
      if (first){ moveTo(x,y); first=false; } else { lineTo(x,y); }
    }
  }
  return mk('path', { d, fill:'none', stroke: color, 'stroke-width': String(width) });
}

function familyDef(key){
  switch(key){
    case 'lin':   return { fn:(x)=>x, segments:[[-3,3]], color: COLORS.ccyan };
    case 'quad':  return { fn:(x)=>x*x, segments:[[-3,3]], color: COLORS.cgreen };
    case 'sin':   return { fn:(x)=>Math.sin(x), segments:[[-6.283,6.283]], color: COLORS.black };
    case 'recip': return { fn:(x)=>1/x, segments:[[-3,-0.2],[0.2,3]], color: COLORS.cblue };
    case 'exp':   return { fn:(x)=>Math.exp(x), segments:[[-2,2.5]], color: COLORS.cmagenta };
    case 'rad':   return { fn:(x)=>Math.sqrt(Math.max(0,x)), segments:[[0,3]], color: COLORS.corange };
    case 'cub':   return { fn:(x)=>x*x*x, segments:[[-2,2]], color: COLORS.cred };
  }
}

function renderPlot(present4){
  PLOT.innerHTML='';
  PLOT.appendChild(axes());
  for (const k of present4){
    const f = familyDef(k);
    PLOT.appendChild(pathFor(f, { color: f.color, width:3.2 }));
  }
}

/* ---------- UI: legend + edges ---------- */
const legend = document.getElementById('legend');
const edgesBox = document.getElementById('edges');
function renderLegend(present4){
  // Clear previous pills
  [...legend.querySelectorAll('.pill')].forEach(el=>el.remove());
  for (const k of present4){
    const fam = byKey[k];
    const pill = document.createElement('div');
    pill.className = 'pill';
    const dot = document.createElement('span');
    dot.className='dot'; dot.style.background = COLORS[fam.color];
    const label = document.createElement('span');
    label.innerHTML = `<strong>${fam.name}</strong> <span class="eq">(${fam.eq})</span>`;
    pill.append(dot, label);
    legend.appendChild(pill);
  }
}

function renderEdges(edges, answerIdx){
  edgesBox.innerHTML='';
  const posNames = ['Top','Right','Left','Bottom'];
  edges.forEach((e, idx)=>{
    const el = document.createElement('div');
    el.className='edge';
    el.dataset.index = idx;
    const col = COLORS[e.color];
    el.innerHTML = `<span style="color:${col}">${e.eq}</span>`;
    edgesBox.appendChild(el);
  });

  // Reveal handler
  document.getElementById('btn-solution').onclick = ()=>{
    [...edgesBox.children].forEach((d,i)=>{
      if (i===answerIdx){ d.classList.remove('wrong'); d.classList.add('correct'); }
      else { d.classList.remove('correct'); d.classList.add('wrong'); }
    });
  };
}

/* ---------- App flow ---------- */
let current = null;

function newCard(){
  current = makeCard();
  renderPlot(current.present4);
  renderLegend(current.present4);
  renderEdges(current.edges, current.answerIdx);
  toast('New card generated');
}

function toast(msg){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(()=>t.classList.remove('show'), 1200);
}

document.getElementById('btn-new').addEventListener('click', newCard);
document.getElementById('btn-solution').addEventListener('click', ()=>{/* wired in renderEdges */});
newCard(); // initial card
</script>
</body>
</html>
