<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prime‑Factor Jumper</title>
  <meta name="description" content="Race the clock to speak the prime/composite sequence. Bright, clean, and classroom-ready."/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&family=JetBrains+Mono:wght@400;600;800&family=STIX+Two+Text:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #f6fbff;
      --ink: #0f172a;
      --muted: #475569;
      --card: #ffffff;
      --accent: #2563eb;
      --accent-2: #f97316;
      --ok: #10b981;
      --warn: #f59e0b;
      --bad: #ef4444;
      --shadow: 0 10px 25px rgba(2, 6, 23, 0.12);
      --r: 22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:
        radial-gradient(1200px 600px at 10% -10%, #e0f2fe 0%, transparent 60%),
        radial-gradient(1200px 600px at 110% 10%, #ffe4e6 0%, transparent 60%),
        var(--bg);
      color:var(--ink); font-family: "Outfit", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "STIX Two Text", serif;
      display:flex; align-items:center; justify-content:center;
    }
    .app{ width:min(1080px, 96vw); }
    header{ display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:16px; }
    .logo{ display:flex; align-items:center; gap:12px; }
    .logo .mark{ font-size:28px; }
    .logo h1{ margin:0; font-weight:800; letter-spacing:.2px; font-size:clamp(22px,3.2vw,30px); }

    .card{ background:var(--card); border-radius:var(--r); box-shadow:var(--shadow); padding:clamp(16px,2.6vw,24px); }
    .controls{ display:grid; grid-template-columns:1fr 1fr 1fr auto; gap:10px; }
    @media (max-width:900px){ .controls{ grid-template-columns:1fr; } }
    label{ font-weight:600; color:var(--muted); }
    select, button, input[type="text"]{ border:1px solid rgba(15,23,42,.1); border-radius:14px; padding:10px 12px; font-size:16px; background:#fff; }
    button{ cursor:pointer; font-weight:800; letter-spacing:.2px; }
    .primary{ background:var(--accent); color:#fff; border:none; }
    .muted{ background:#f8fafc; color:var(--muted); }
    .danger{ background:var(--bad); color:#fff; border:none; }

    .columns{ display:grid; grid-template-columns: 1fr; gap:16px; }

    @media (max-width:900px){ .columns{ grid-template-columns:1fr; } }

    .timer{ height:10px; background:#e2e8f0; border-radius:999px; overflow:hidden; margin-bottom:12px; }
    .timer > .bar{ height:100%; width:100%; background:linear-gradient(90deg, var(--ok), var(--warn), var(--bad)); transition: width .15s linear; }
    .timer.unlimited{ background:transparent; }

    .question{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .n{ font-family:"STIX Two Text", serif; font-weight:800; font-size: clamp(34px, 7vw, 58px); letter-spacing:.4px; }

    .answer{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    input[type="text"]{ font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:clamp(18px,3vw,22px); min-width:220px; padding:12px 14px; }

    .feedback{ min-height:28px; font-weight:700; }
    .ok{ color:var(--ok) }
    .bad{ color:var(--bad) }

    .shake{ animation:shake .25s linear 2; }
    @keyframes shake{ 0%{transform:translateX(0)}25%{transform:translateX(4px)}50%{transform:translateX(-4px)}75%{transform:translateX(3px)}100%{transform:translateX(0)} }

    .hidden{ display:none !important; }
    /* Center the question row and hide the small jump widget */
    .question{ display:flex; align-items:center; justify-content:center; text-align:center; gap:12px; }
    
    /* Hide the current n so students must remember it */
    .n{ display:none; }
  
    /* Make the card a positioning context for the skull overlay */
    .card{ position: relative; }
    
    /* Skull overlay */
    .skull{
      position:absolute; inset:0;
      display:none;            /* shown by adding .show */
      align-items:center; justify-content:center;
      font-size: clamp(80px, 12vw, 160px);
      pointer-events:none;     /* overlay is visual only */
    }
    .skull.show{ display:flex; }

    /* Compact HUD above the timer */
    .hud{
      display:grid;
      grid-template-columns: repeat(4, auto);
      gap:12px;
      align-items:end;
      justify-content:space-between;
      margin-bottom:8px; /* space before the time bar */
    }
    .hud-item{ text-align:center; }
    .hud-k{ font-weight:800; font-size: clamp(16px, 2.2vw, 22px); }
    .hud-v{ color:var(--muted); font-size:12px; text-transform:uppercase; letter-spacing:.3px; }
    
    /* Stack on small screens */
    @media (max-width: 560px){
      .hud{
        grid-template-columns: repeat(2, auto);
        row-gap:6px;
      }
    }

    /* Tighter spacing for the block under the timer */
    .question { margin: 6px 0 4px; }
    
    /* Make the big jump clear but compact */
    .nextjump-big{
      font-weight:700;
      letter-spacing:.2px;
      line-height:1.08;
      font-size: clamp(18px, 3.4vw, 28px);
      margin: 0;             /* remove extra space */
    }
    
    /* Starting point: smaller and lighter */
    .startpoint{
      margin-top: 2px;
      font-weight: 600;
      color: var(--muted);
      font-size: 13px;
    }
    
    /* Stack input and buttons vertically; center them */
    .answer{
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
    }
    
    /* Wider input, centered text */
    #answer{
      width: min(460px, 92%);
      text-align: center;
    }
    
    /* Put buttons on a single compact row */
    .answer .actions{
      display:flex;
      gap: 8px;
    }
    
    /* Make Submit prominent, Skip quiet */
    #btnSubmit{ font-weight:800; }
    
    /* Feedback: subtle and small to reduce noise */
    #feedback{
      margin-top: 6px;
      font-weight: 600;
      font-size: 13px;
      color: var(--muted);
    }
    #feedback.ok{ color: var(--ok); }
    #feedback.bad{ color: var(--bad); }
    .startpoint{ display:none; }

    /* separator before rules/legend */
    .sep{
      border:0; height:1px; background:#e5e7eb; margin:12px 0;
    }
    
    /* container for rules + legend inside the main card */
    .rules-legend{ margin-top:4px; color:var(--muted); }
    .rules-legend .subtle{ margin:8px 0 6px; font-size:14px; color:var(--muted); }
    .rules-legend p{ margin:0 0 8px 0; }
    

    /* Let us position an overlay inside the answer area */
    .answer{ position: relative; }
    
    /* Green overlay button that covers the input area until Start is pressed */
    #overlayStart{
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      border-radius: 14px;
      background: var(--accent); /* same color as .primary Start button */
      color: #fff;
      font-weight: 800;
      font-size: clamp(14px, 2.6vw, 18px);
      border: none;
      box-shadow: var(--shadow);
      z-index: 2;                 /* sit above the input/buttons */
      cursor: default;            /* visual button; tells user to press Start */
    }

    /* Red flash for lost life (reuses .skull positioning) */
    .skull.is-flash{
      color: var(--bad);
      animation: flashOut .65s ease;
    }
    @keyframes flashOut{
      0%{ opacity:0; transform:scale(.92) }
      15%{ opacity:1; transform:scale(1) }
      85%{ opacity:1 }
      100%{ opacity:0 }
    }

    /* Make the overlays sit above all UI */
    .skull{ z-index: 10000; }     /* applies to both skull and red flash */
    #flash{ z-index: 10001; }     /* ensure the red flash is above the skull if both showed */

    .rules-legend ul.ins{ margin:0; padding-left:18px; }
    .rules-legend ul.ins li{ margin:4px 0; }
    .rules-legend code{ font-family:"JetBrains Mono", monospace; }
    .rules-legend kbd{
      display:inline-block;
      padding:0 .4em;
      border:1px solid #cbd5e1;
      border-bottom-width:2px;
      border-radius:6px;
      background:#f8fafc;
      font-family:"JetBrains Mono", monospace;
      font-size:.95em;
    }

    /* Centered header + frog title */
    header.hero{
      display:flex;
      flex-direction:column;
      align-items:center;
      text-align:center;
      gap:12px;
      margin-bottom:16px;
    }
    header.hero .title{
      margin:0;
      font-weight:800;
      letter-spacing:.2px;
      font-size: clamp(28px, 4.2vw, 40px);
    }
    header.hero .title .frog{ font-size: 1.1em; margin-right:.3em; }
    
    /* Controls row: Difficulty | Jumps | Start | Reset (Start-at hidden) */
    .controls.controls-row{
      width:min(700px, 96vw);   /* narrower container => buttons closer */
      display:grid;
      grid-template-columns: 1fr 1fr 1fr auto auto;
      gap:6px;                  /* tighten spacing between controls */
      margin-inline:auto;       /* keep it centered */
    }


    
    /* Ensure the button cells don’t stretch weirdly */
    .controls .only-buttons{
      display:flex;
      align-items:end;
      justify-content:center;
    }

    /* ===== Mobile polish (phones & small tablets) ===== */
    @media (max-width: 700px){
      /* overall spacing */
      .app{ width:100vw; padding:8px; }
      .card{ padding:12px; border-radius:16px; }
    
      /* header/title & HUD */
      header.hero{ gap:8px; margin-bottom:12px; }
      header.hero .title{ font-size: clamp(22px, 6vw, 28px); }
      .hud{ gap:8px; margin-bottom:6px; }
      .timer{ height:8px; margin-bottom:8px; }
    
      /* controls row: stack into two columns; buttons become full width */
      .controls.controls-row{
        width:100%;
        grid-template-columns: 1fr 1fr;   /* 2 columns on mobile */
        gap:6px;
        margin-inline:auto;
      }
      .controls.controls-row label{
        margin:0 0 2px; font-size:12px; line-height:1.1;
      }
      .controls.controls-row select,
      .controls.controls-row button{
        height:40px; padding:0 10px; font-size:16px; border-radius:10px;
      }
      .controls.controls-row .only-buttons{ grid-column: 1 / -1; }   /* span both columns */
      .controls.controls-row .only-buttons button{ width:100%; }     /* full-width Start/Reset */
    
      /* jump & input area */
      .question{ margin:6px 0 4px; }
      .nextjump-big{ font-size: clamp(18px, 5.2vw, 24px); line-height:1.1; }
      #answer{ width:100%; max-width:100%; text-align:center; }
      .answer .actions{ width:100%; }
      #btnSubmit{ width:100%; }  /* big target on mobile */
    
      /* feedback & instructions */
      #feedback{ font-size:12px; margin-top:6px; }
      .rules-legend{ font-size:14px; }
    }
    
    /* ultra-small phones */
    @media (max-width: 360px){
      .controls.controls-row{ gap:4px; }
      .controls.controls-row select,
      .controls.controls-row button{ height:38px; padding:0 8px; }
      header.hero .title{ font-size: clamp(20px, 6.5vw, 24px); }
    }


  </style>
</head>
<body>
<div class="app">
  <header class="hero">
  <h1 class="title"><span class="frog" aria-hidden="true">🐸</span> Prime Jumper <span class="frog" aria-hidden="true">🐸</span></h1>

  <div class="controls card controls-row">
    <div>
      <label for="difficulty">Difficulty</label><br>
      <select id="difficulty">
        <option value="unlimited">Easy — unlimited</option>
        <option value="10">Medium — 10s</option>
        <option value="5">Hard — 5s</option>
        <option value="2">Super Hard — 2s</option>
      </select>
    </div>

    <div>
      <label for="jumps">Jumps</label><br>
      <select id="jumps">
        <option value="off">Off</option>
        <option value="light">Light</option>
        <option value="normal" selected>Normal</option>
        <option value="chaos">Chaotic</option>
      </select>
    </div>

    <!-- keep Start-at in DOM for JS, but we'll hide it with CSS -->
    <div class="startAt-block">
      <label for="startAt">Start at</label><br>
      <select id="startAt">
        <option value="2" selected>2</option>
        <option value="3">3</option>
        <option value="5">5</option>
        <option value="7">7</option>
        <option value="11">11</option>
      </select>
    </div>

    <div class="only-buttons">
      <button id="btnStart" class="primary">Start ▶</button>
    </div>
    <div class="only-buttons">
      <button id="btnReset" class="muted">Reset</button>
    </div>
  </div>
</header>


  <div class="columns">
    <section class="card" aria-live="polite">
      <div class="hud">
        <div class="hud-item"><div class="hud-k" id="kScore">0</div><div class="hud-v">Score</div></div>
        <div class="hud-item"><div class="hud-k" id="kStreak">0</div><div class="hud-v">Streak</div></div>
        <div class="hud-item"><div class="hud-k" id="kLives">❤❤❤</div><div class="hud-v">Lives</div></div>
        <div class="hud-item"><div class="hud-k" id="kBest">0</div><div class="hud-v">Best</div></div>
      </div>

      <div id="timer" class="timer"><div class="bar" style="width:100%"></div></div>

      <div class="question">
        <div class="n" id="qNumber">n = —</div>  <!-- stays in DOM but is hidden by CSS -->
        <div class="nextjump-big" id="nextJumpBig"></div>
        <div id="startPoint" class="startpoint">Starting point: 2</div>
      </div>
      
      <!-- skull overlay (stays inside the same <section class="card">) -->
      <div id="skull" class="skull" aria-hidden="true">☠️</div>
      <div id="flash" class="skull" aria-hidden="true"></div>


      

      <div class="answer">
        <input id="answer" type="text" inputmode="numeric" autocomplete="off"
               placeholder="Type answer (e.g., 222 for 8)" />
        <div class="actions">
          <button id="btnSubmit" class="primary">Submit ⏎</button>
        </div>
      
        <!-- Overlay that covers the input until Start is pressed -->
        <button id="overlayStart">Press Start To Begin</button>
      </div>



      <div class="feedback" id="feedback">Press Enter to submit · “×/x” are ignored</div>
      <hr class="sep">

      <div class="rules-legend">
        <h3 class="subtle">Instructions</h3>
        <ul class="ins">
          <li>From the current number, apply the “Jump” shown (e.g., <em>Jump 1 Up</em> → +1) to get the <strong>next</strong> integer.</li>
          <li>If the next integer is <strong>prime</strong>, type the number (e.g., 11 → <code>11</code>).</li>
          <li>If it’s <strong>composite</strong>, type its prime factors concatenated in ascending order (e.g., 12 → 2×2×3 → <code>223</code>).</li>
          <li>Digits only. You can type <code>x</code> or <code>×</code> — they’re ignored.</li>
          <li><strong>Lives:</strong> You have 3 ❤. A wrong answer or timeout loses one.</li>
          <li><strong>Red flash:</strong> briefly shows the correct next number you should have entered; the sequence continues from that value.</li>
          <li><strong>Never below 2:</strong> the sequence cannot drop below 2 (from 2 it moves to at least 3).</li>
          <li><strong>Game over:</strong> when lives reach 0, a ☠️ covers the screen.</li>
          <li><strong>Hotkeys:</strong> <kbd>S</kbd> Start, <kbd>Esc</kbd> Reset, <kbd>Enter</kbd> Submit.</li>
        </ul>
      </div>


    </section>
    
  </div>
</div>

<script>
  // ——— Primes & factorization ———
  function isPrime(n){
    if(n < 2) return false;
    if(n % 2 === 0) return n === 2;
    if(n % 3 === 0) return n === 3;
    let i = 5, w = 2;
    while(i * i <= n){ if(n % i === 0) return false; i += w; w = 6 - w; }
    return true;
  }
  function primeFactors(n){
    const f = [];
    while(n % 2 === 0){ f.push(2); n/=2; }
    let d = 3;
    while(d * d <= n){ while(n % d === 0){ f.push(d); n/=d; } d += 2; }
    if(n > 1) f.push(n);
    return f;
  }
  function expectedInput(n){
    return isPrime(n) ? String(n) : primeFactors(n).map(String).join('');
  }
  function expr(n){
    return isPrime(n) ? String(n) : primeFactors(n).join('×');
  }

  // ——— Elements ———
  const el = (id)=>document.getElementById(id);
  const qNumber = el('qNumber');
  const answer = el('answer');
  const feedback = el('feedback');
  const timerWrap = el('timer');
  const bar = timerWrap.querySelector('.bar');
  const kScore = el('kScore');
  const kStreak = el('kStreak');
  const kLives = el('kLives');
  const kBest = el('kBest');

  const btnStart = el('btnStart');
  const btnReset = el('btnReset');
  const btnSubmit = el('btnSubmit');

  const ddDiff = el('difficulty');
  const ddJumps = el('jumps');
  const ddStartAt = el('startAt');

  // ——— Jumps ———
  const JUMPS = {
    '+3': { delta: 3, symbol:'⚡', label:'Plus 3' },
    '+2': { delta: 2, symbol:'⏩', label:'Plus 2' },
    '+1': { delta: 1, symbol:'➕', label:'Plus 1' },
    '-1': { delta:-1, symbol:'↩️', label:'Back 1' },
    '-3': { delta:-3, symbol:'🌀', label:'Back 3' },
  };
  function pickNextJump(){
    const mode = ddJumps.value;
    if (mode === 'off') return null;
  
    const base = Number(state?.n ?? 2);
  
    // Separate bags for up vs. down; weight ups much more heavily
    const up = [], down = [];
    const push = (arr, k, w)=>{ for (let i=0;i<w;i++) arr.push(k); };
  
    if (mode === 'light'){
      // mostly small positive moves
      push(up,'+1',8); push(up,'+2',3); push(up,'+3',1);
      push(down,'-1',1);                                     // very rare
    } else if (mode === 'normal'){
      push(up,'+1',7); push(up,'+2',4); push(up,'+3',2);
      push(down,'-1',1);                                     // very rare
    } else { // 'chaos' — still biased up, but can include -3 occasionally
      push(up,'+1',6); push(up,'+2',5); push(up,'+3',3);
      push(down,'-1',1); push(down,'-3',1);                  // both rare
    }
  
    // Never allow a jump that would drop below 2 from the current n
    const upSafe   = up.filter(k   => base + JUMPS[k].delta >= 2);
    const downSafe = down.filter(k => base + JUMPS[k].delta >= 2);
  
    // Make down jumps quite infrequent
    const P_DOWN = 0.12; // ≈12% of jumps (tune smaller for even fewer downs)
  
    let pool;
    if (downSafe.length && Math.random() < P_DOWN){
      pool = downSafe;
    } else {
      pool = upSafe.length ? upSafe : (downSafe.length ? downSafe : up); // fallback safety
    }
  
    const key = pool[Math.floor(Math.random() * pool.length)];
    return JUMPS[key];
  }


  
  function showJump(next){
    const big = document.getElementById('nextJumpBig');
    if(!big) return;
    if(!next){ big.textContent = ''; return; }
  
    // Use the *effective* target (after floor rules) to decide Up/Down label.
    // If state.target is already computed this round, use it; otherwise estimate it.
    let cand = Number.isFinite(state.target) ? state.target : (state.n + next.delta);
  
    // Apply the same floors you use in nextRound()
    if (cand < 2) cand = 2;
    if (state.n === 2 && cand <= 2) cand = 3;
  
    const eff = cand - state.n;
    const mag = Math.abs(eff);
    const dir = eff >= 0 ? 'Up' : 'Down';
  
    big.textContent = `Jump ${mag} ${dir}`;
  }



  // ——— State ———
  let state = {
    running:false, paused:false,
    score:0, streak:0, lives:3, best:Number(localStorage.getItem('pfs_best')||0),
    n: Number((el('startAt')?.value)||2),        // current term (displayed)
    target: Number((el('startAt')?.value)||2),   // next term to answer for (after jump)
    lastMax: Number((el('startAt')?.value)||2) - 1,
    nextJump:null,
    timePer:Infinity, timeLeft:Infinity, timerId:null,
  };
  kBest.textContent = String(state.best);

  // ——— Timing ———
  function setDifficulty(val){ state.timePer = (val==='unlimited') ? Infinity : Number(val); }
  function setTimerUI(){
    if(!isFinite(state.timePer)) { timerWrap.classList.add('unlimited'); bar.style.width = '100%'; return; }
    timerWrap.classList.remove('unlimited');
    const pct = Math.max(0, Math.min(1, state.timeLeft / state.timePer));
    bar.style.width = (pct*100).toFixed(1)+'%';
  }
  function startTicking(){
    clearInterval(state.timerId);
    if(!isFinite(state.timePer)) { setTimerUI(); return; }
    state.timerId = setInterval(()=>{
      if(!state.running || state.paused) return;
      state.timeLeft -= 0.1;
      if(state.timeLeft <= 0){ state.timeLeft = 0; setTimerUI(); timesUp(); }
      else setTimerUI();
    }, 100);
  }

  // ——— Game flow ———
  function resetGame(){
    state.running=false; state.paused=false; clearInterval(state.timerId);
    state.lives=3; state.score=0; state.streak=0;
    state.n = Math.max(2, Number(ddStartAt.value) || 2);
    document.getElementById('startPoint').textContent = `Starting point: ${state.n}`;
    document.getElementById('skull')?.classList.remove('show');
    state.target = state.n;                // will be set in nextRound()
    state.lastMax = state.n - 1;           // ensures strict forward motion
    state.nextJump = pickNextJump();
    setDifficulty(ddDiff.value);
    updateHUD();
    qNumber.textContent = `n = —`;
    feedback.textContent = 'Ready! Press Start.'; feedback.className = 'feedback';
    answer.value='';
    showJump(state.nextJump);
    state.timeLeft = state.timePer; setTimerUI();
    document.getElementById('overlayStart')?.classList.remove('hidden');
  }

  function startGame(){
    resetGame(); // this shows the overlay
    document.getElementById('overlayStart')?.classList.add('hidden'); // now hide it
    state.running = true;
    state.paused = false;
    nextRound();
  }



  // Display the CURRENT term, but compute the NEXT term as target
  function nextRound(){
    const j = state.nextJump;
    let candidate = j ? (state.n + j.delta) : (state.n + 1);
    
    // Hard floor: never below 2
    if (candidate < 2) candidate = 2;
    
    // If we're already at the floor (n = 2), always move forward at least to 3
    if (state.n === 2 && candidate <= 2) candidate = 3;
    
    // Soft floor (optional): allow some backtracking but not more than 5 below the farthest reached
    const softFloor = Math.max(2, state.lastMax - 5);
    if (candidate < softFloor) candidate = softFloor;

  
    state.target = candidate;
  
    qNumber.textContent = `n = ${state.n}`;
    showJump(state.nextJump);
  
    answer.value=''; answer.focus();
    state.timeLeft = state.timePer; setTimerUI(); startTicking();
  }



  // Recent UI removed — make this a no-op to avoid errors
  function addHistory(){ /* no-op */ }


  function updateHUD(){
    kScore.textContent = String(state.score);
    kStreak.textContent = String(state.streak);
    kLives.textContent = '❤'.repeat(state.lives) + '♡'.repeat(3 - state.lives);
    kBest.textContent = String(state.best);
  }

  function proceed(){
    // Accept the next term and prepare the following round
    state.lastMax = Math.max(state.lastMax, state.target);
    state.n = Math.max(2, state.target);         // hard floor at 2, always
                     // ✅ move to the term the student just produced
    state.nextJump = pickNextJump();             // next jump affects the NEXT target
    nextRound();
  }

  function endGame(reason){
    document.getElementById('skull')?.classList.add('show');
    state.running=false; clearInterval(state.timerId);
    feedback.textContent = `Game over — ${reason}`; feedback.className='feedback bad';
    qNumber.textContent = 'n = —';
    showJump(null);
    updateHUD();
  }

  function flashPrev(){
    const flash = document.getElementById('flash');
    if(!flash) return;
    // Show the NEXT number in the sequence (what the user should have entered)
    flash.textContent = String(state.target);
    flash.classList.add('show','is-flash');
    setTimeout(()=> flash.classList.remove('show','is-flash'), 650);
  }

  function miss(reason){
    state.lives -= 1; state.streak = 0; updateHUD();
    if(state.lives <= 0) { endGame(reason); return; }
  
    flashPrev(); // shows the expected next number (e.g., 4 when n=3 & Jump 1 Up)
  
    feedback.textContent = reason + ' Next!'; feedback.className='feedback bad';
    proceed(); // sets state.n = state.target and continues the sequence
  }

  function timesUp(){ if(!state.running) return; miss("Time's up!"); }

  function submit(){
    if(!state.running || state.paused) return;
    const raw = answer.value.trim();
    if(!raw){ answer.classList.add('shake'); setTimeout(()=>answer.classList.remove('shake'), 300); return; }
    const cleaned = raw.replace(/[xX×\s]/g, '');
    if(!/^\d+$/.test(cleaned)){
      feedback.textContent = 'Digits only please (×, x allowed but ignored).';
      feedback.className = 'feedback bad';
      answer.classList.add('shake'); setTimeout(()=>answer.classList.remove('shake'), 300);
      return;
    }
    const want = expectedInput(state.target);   // ✅ expect input for the NEXT term
    if(cleaned === want){
      state.score += 1; state.streak += 1;
      if(state.score > state.best){
        state.best = state.score; localStorage.setItem('pfs_best', String(state.best));
      }
      feedback.textContent = 'Correct!'; feedback.className='feedback ok'; updateHUD();
      // Log the current term they stood on (optional; keeps chips consistent)
      addHistory(state.n, expr(state.n), true);
      proceed();
    } else {
      feedback.textContent = `Not quite. Expected: “${want}” (i.e., ${expr(state.target)}).`;
      feedback.className='feedback bad';
      answer.classList.add('shake'); setTimeout(()=>answer.classList.remove('shake'), 300);
      miss('Wrong answer.');
    }
  }

  function resetBest(){
    state.best = 0;
    localStorage.removeItem('pfs_best'); // clear persisted best
    updateHUD();                         // refresh the HUD (kBest -> 0)
  }

  // ——— Events ———
  btnStart.addEventListener('click', startGame);
  btnReset.addEventListener('click', resetGame);
  btnSubmit.addEventListener('click', submit);
  ddDiff.addEventListener('change', ()=>{
    setDifficulty(ddDiff.value);
    resetBest();
  });
  ddJumps.addEventListener('change', resetBest);
  ddStartAt.addEventListener('change', resetBest);

  // Keyboard shortcuts
  answer.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); submit(); }});
  document.addEventListener('keydown', (e)=>{
    const targetIsInput = document.activeElement === answer;
  
    // S → Start (don’t trigger while typing in the input)
    if (e.key === 's' || e.key === 'S') {
      if (!targetIsInput) {
        e.preventDefault();
        startGame();    // same as clicking Start ▶
      }
      return;
    }
  
    // Esc → Reset (always allowed)
    if (e.key === 'Escape') {
      e.preventDefault();
      resetGame();      // same as clicking Reset
      return;
    }
  
    // Enter → Submit (only when focus isn’t in the input)
    if (e.key === 'Enter' && !targetIsInput) {
      submit();
    }
  });


  // Boot
  resetGame();
</script>


</body>
</html>
