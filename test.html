<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Coordinate Dash Worksheet</title>
  <style>
    :root {
      --bg: #0f172a;           /* slate-900 */
      --panel: #111827;        /* gray-900 */
      --muted: #94a3b8;        /* slate-400 */
      --text: #e5e7eb;         /* gray-200 */
      --accent: #22d3ee;       /* cyan-400 */
      --accent-2: #a78bfa;     /* violet-400 */
      --ok: #22c55e;           /* green-500 */
      --warn: #f59e0b;         /* amber-500 */
      --danger: #ef4444;       /* red-500 */
      --card: #0b1220;         /* custom dark card */
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
        Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji",
        "Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 80% -10%, #1f2937, transparent),
                  radial-gradient(1000px 700px at -10% 120%, #1e293b, transparent),
                  var(--bg);
      color: var(--text);
      line-height: 1.5;
    }
    .container {
      max-width: 980px;
      margin: 32px auto;
      padding: 0 16px;
    }
    header {
      display: grid;
      gap: 12px;
      padding: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    header h1 {
      margin: 0 0 4px 0;
      font-size: 28px;
      letter-spacing: 0.2px;
    }
    header p { margin: 0; color: var(--muted); }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 10px;
    }
    .control {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .control label { display: block; font-size: 12px; color: var(--muted); }
    .control input, .control select {
      width: 100%;
      margin-top: 6px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0a0f1a;
      color: var(--text);
      outline: none;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 6px;
    }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--text);
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 200ms ease, border-color 200ms ease;
    }
    button:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.25); }
    button.primary { border-color: rgba(34, 211, 238, 0.7); background: linear-gradient(180deg, rgba(34,211,238,0.18), rgba(34,211,238,0.08)); }
    button.success { border-color: rgba(34,197,94,0.7); background: linear-gradient(180deg, rgba(34,197,94,0.18), rgba(34,197,94,0.08)); }
    button.warn { border-color: rgba(245,158,11,0.7); background: linear-gradient(180deg, rgba(245,158,11,0.18), rgba(245,158,11,0.08)); }

    .grid {
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 16px;
      margin-top: 20px;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .panel h2 { margin-top: 0; font-size: 20px; }

    .list { display: grid; gap: 12px; }
    .card {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px;
    }
    .step-head {
      display: flex; align-items: center; justify-content: space-between; gap: 10px;
    }
    .step-desc { font-weight: 600; }
    .step-actions { display: flex; gap: 8px; }
    .answer { margin-top: 8px; color: var(--accent); font-weight: 600; display: none; }

    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; color: #0b1220;
    }
    .badge.seed { background: var(--accent); }
    .badge.bound { background: var(--accent-2); color: #0b1220; }

    .muted { color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }

    .timer {
      font-variant-numeric: tabular-nums;
      font-size: 28px;
      letter-spacing: 1px;
      padding: 8px 12px;
      background: #0a0f1a;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      display: inline-block;
      min-width: 130px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Interactive Coordinate Dash Worksheet</h1>
      <p class="muted">Generate deterministic practice with a <strong>seed</strong>,
        reveal each <strong>intermediate coordinate</strong> step-by-step, and keep time with the built-in
        <strong>timer</strong>. Perfect for GitHub Pages or any static host.</p>

      <div class="controls">
        <div class="control">
          <label for="seedInput">Seed</label>
          <input id="seedInput" type="text" placeholder="e.g. 12345 or any text" />
        </div>
        <div class="control">
          <label for="stepsInput">Number of steps</label>
          <select id="stepsInput">
            <option>4</option>
            <option selected>6</option>
            <option>8</option>
            <option>10</option>
          </select>
        </div>
        <div class="control">
          <label for="boundInput">Coordinate bound (inclusive)</label>
          <select id="boundInput">
            <option>8</option>
            <option selected>10</option>
            <option>12</option>
            <option>15</option>
          </select>
        </div>
        <div class="control">
          <label>Timer</label>
          <div class="row">
            <span class="timer" id="timer">00:00</span>
            <div class="buttons">
              <button class="warn" id="startBtn">Start</button>
              <button id="stopBtn">Stop</button>
              <button id="resetBtn">Reset</button>
            </div>
          </div>
        </div>
        <div class="control">
          <label>&nbsp;</label>
          <div class="buttons">
            <button class="primary" id="generateBtn">Generate</button>
            <button class="success" id="revealAllBtn">Reveal all</button>
            <button id="copyLinkBtn" title="Copy link with current seed & options">Copy link</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:6px">
        <span id="meta" class="muted mono">&nbsp;</span>
      </div>
    </header>

    <div class="grid">
      <section class="panel">
        <h2>Question</h2>
        <div id="question"></div>
      </section>

      <section class="panel">
        <h2>Answer (step-by-step)</h2>
        <div id="answers" class="list"></div>
      </section>
    </div>
  </div>

  <script>
    // ===== Deterministic RNG (mulberry32) + string hashing =====
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }
    function hashStringToSeed(str) {
      // simple 32-bit FNV-1a hash
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    // RNG helpers using a current PRNG instance
    let rng = mulberry32(123456789);
    function reseed(seedVal) {
      let seed;
      if (typeof seedVal === 'number' && Number.isFinite(seedVal)) seed = seedVal >>> 0;
      else if (typeof seedVal === 'string' && seedVal.trim().length) seed = hashStringToSeed(seedVal.trim());
      else seed = (Date.now() ^ Math.floor(Math.random() * 1e9)) >>> 0;
      rng = mulberry32(seed);
      return seed;
    }
    function rand() { return rng(); }
    function randint(min, max) { // inclusive
      return Math.floor(rand() * (max - min + 1)) + min;
    }
    function choice(arr) { return arr[Math.floor(rand() * arr.length)]; }

    // ===== Transformations =====
    function random_translation() {
      const direction = choice(["up", "down", "left", "right"]);
      const magnitude = randint(1, 5);
      const desc = `Translate ${magnitude} unit${magnitude===1?'':'s'} ${direction}`;
      function fn(x, y) {
        if (direction === 'up') return [x, y + magnitude];
        if (direction === 'down') return [x, y - magnitude];
        if (direction === 'right') return [x + magnitude, y];
        return [x - magnitude, y];
      }
      return [desc, fn];
    }

    function random_reflection() {
      const axis = choice(["x-axis", "y-axis", "line"]);
      if (axis === 'x-axis') return ["Reflect over x-axis", (x, y) => [x, -y]];
      if (axis === 'y-axis') return ["Reflect over y-axis", (x, y) => [-x, y]];
      const lineType = choice(["x=", "y="]);
      const value = randint(-3, 3);
      if (lineType === 'x=') return [`Reflect over the line x = ${value}`, (x, y) => [2*value - x, y]];
      return [`Reflect over the line y = ${value}`, (x, y) => [x, 2*value - y]];
    }

    function random_rotation() {
      const angle = choice([90, -90]);
      const pivot = [randint(-5, 5), randint(-5, 5)];
      const arrow = angle === 90 ? '↺' : '↻'; // CCW vs CW
      const desc = `Rotate ${Math.abs(angle)}° ${arrow} about the point (${pivot[0]}, ${pivot[1]})`;
      function fn(x, y) {
        const [x0, y0] = pivot;
        const dx = x - x0, dy = y - y0;
        if (angle === 90) return [x0 - dy, y0 + dx];
        return [x0 + dy, y0 - dx];
      }
      return [desc, fn];
    }

    function generate_random_transformation() {
      return choice([random_translation, random_reflection, random_rotation])();
    }

    // ===== UI / Logic =====
    const questionEl = document.getElementById('question');
    const answersEl = document.getElementById('answers');
    const seedInput = document.getElementById('seedInput');
    const stepsInput = document.getElementById('stepsInput');
    const boundInput = document.getElementById('boundInput');
    const generateBtn = document.getElementById('generateBtn');
    const revealAllBtn = document.getElementById('revealAllBtn');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const metaEl = document.getElementById('meta');

    // Timer controls
    const timerEl = document.getElementById('timer');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');

    let timerHandle = null;
    let elapsedSec = 0;

    function fmtTime(sec) {
      const m = Math.floor(sec / 60); const s = sec % 60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }
    function timerStart() {
      if (timerHandle) return;
      timerHandle = setInterval(() => { elapsedSec++; timerEl.textContent = fmtTime(elapsedSec); }, 1000);
    }
    function timerStop() { if (timerHandle) { clearInterval(timerHandle); timerHandle = null; } }
    function timerReset() { timerStop(); elapsedSec = 0; timerEl.textContent = fmtTime(elapsedSec); }

    startBtn.addEventListener('click', timerStart);
    stopBtn.addEventListener('click', timerStop);
    resetBtn.addEventListener('click', timerReset);

    function renderQuestion(startPt, transformDescs) {
      const startHTML = `<div class="card"><div class="step-head"><span class="step-desc">Starting coordinate:</span><span class="mono">( \,\,\,\,\, , \,\,\,\,\, )</span></div></div>`;
      const list = transformDescs.map(d => `<li>${d}</li>`).join('');
      questionEl.innerHTML = `
        <div class="card">
          <div class="row" style="justify-content: space-between; align-items: baseline;">
            <div>
              <strong>Starting coordinate:</strong>
              <span class="mono">(\u2007\u2007\u2007\u2007\u2007, \u2007\u2007\u2007\u2007\u2007)</span>
            </div>
            <div class="row">
              <span class="badge seed" title="Seed used for RNG">seeded</span>
              <span class="badge bound" title="Coordinate bound">bound ±${boundInput.value}</span>
            </div>
          </div>
        </div>
        <div class="card">
          <ol>${list}</ol>
        </div>`;
    }

    function renderAnswers(startPt, steps) {
      answersEl.innerHTML = '';
      const startCard = document.createElement('div');
      startCard.className = 'card';
      startCard.innerHTML = `<div class="step-head"><span class="step-desc">0 · Start</span><span class="mono">(${startPt[0]}, ${startPt[1]})</span></div>`;
      answersEl.appendChild(startCard);

      steps.forEach((step, idx) => {
        const [desc, coord] = step;
        const card = document.createElement('div');
        card.className = 'card';
        const ansId = `ans-${idx}`;
        card.innerHTML = `
          <div class="step-head">
            <div class="step-desc">${idx+1} · ${desc}</div>
            <div class="step-actions">
              <button class="primary" data-target="${ansId}">Show result</button>
            </div>
          </div>
          <div class="answer mono" id="${ansId}">(${coord[0]}, ${coord[1]})</div>
        `;
        answersEl.appendChild(card);
      });

      // Wire up per-step reveal buttons
      answersEl.querySelectorAll('button[data-target]').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.getAttribute('data-target');
          const el = document.getElementById(id);
          const vis = el.style.display === 'block';
          el.style.display = vis ? 'none' : 'block';
          btn.textContent = vis ? 'Show result' : 'Hide result';
        });
      });
    }

    function generate() {
      const stepsN = parseInt(stepsInput.value, 10) || 6;
      const BOUND = parseInt(boundInput.value, 10) || 10;
      const seedText = seedInput.value.trim();
      const seedUsed = reseed(seedText.length ? seedText : undefined);

      // Starting coordinate inside bounds (shy 1 to avoid overflow with small translations)
      const start = [ randint(-BOUND + 1, BOUND - 1), randint(-BOUND + 1, BOUND - 1) ];

      // Build transformations
      const tforms = Array.from({ length: stepsN }, () => generate_random_transformation());
      const descs = tforms.map(t => t[0]);

      // Apply + record intermediates
      let [x, y] = start;
      const steps = [];
      for (const [desc, fn] of tforms) {
        [x, y] = fn(x, y);
        steps.push([desc, [x, y]]);
      }

      // Render
      renderQuestion(start, descs);
      renderAnswers(start, steps);

      // Update meta
      metaEl.textContent = `Seed: ${seedUsed} · Start: (${start[0]}, ${start[1]}) · Final: (${x}, ${y}) · Steps: ${stepsN}`;

      // Reset & start timer automatically
      timerReset();
      timerStart();

      // Update URL hash with options (for shareable links)
      const params = new URLSearchParams({ seed: seedText || String(seedUsed), steps: String(stepsN), bound: String(BOUND) });
      history.replaceState(null, '', `${location.pathname}#${params.toString()}`);
    }

    // Global buttons
    generateBtn.addEventListener('click', generate);
    revealAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.answer').forEach(el => el.style.display = 'block');
      document.querySelectorAll('button[data-target]').forEach(btn => btn.textContent = 'Hide result');
      timerStop(); // optional: stop timing when answers are revealed
    });
    copyLinkBtn.addEventListener('click', async () => {
      const url = location.href;
      try { await navigator.clipboard.writeText(url); copyLinkBtn.textContent = 'Copied!'; setTimeout(() => copyLinkBtn.textContent = 'Copy link', 1200); }
      catch { alert('Copy failed. You can copy the URL from the address bar.'); }
    });

    // Load options from URL hash on first visit
    function initFromHash() {
      if (!location.hash) return false;
      const q = new URLSearchParams(location.hash.slice(1));
      const seed = q.get('seed'); if (seed) seedInput.value = seed;
      const steps = q.get('steps'); if (steps) stepsInput.value = steps;
      const bound = q.get('bound'); if (bound) boundInput.value = bound;
      return true;
    }

    // First render
    initFromHash();
    generate();
  </script>
</body>
</html>
