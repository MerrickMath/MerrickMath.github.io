<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Graph Blitz</title>
<style>
  :root{
    /* Light theme */
    --bg:#f7f9fc; --ink:#0b1220; --muted:#5a6c8f; --panel:#ffffff; --border:#dde3f0;
    --ccyan:#009999; --cgreen:#009900; --cblue:#0000cc; --cmagenta:#ff00ff; --corange:#ff8000; --cred:#ff0000; --cblack:#111111;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif; color:var(--ink); background:var(--bg)}
  header{padding:20px 16px; display:flex; gap:12px; align-items:center; justify-content:space-between; max-width:1100px; margin:0 auto; flex-wrap:wrap;}
  h1{margin:0; font-size:22px; letter-spacing:.3px; font-weight:700}
  .instructions{font-size:13px;color:var(--muted);background:#fbfdff;border:1px solid var(--border);border-radius:8px;padding:8px 10px;margin-top:6px;max-width:700px}
  .controls{display:flex; gap:10px; flex-wrap:wrap}
  button{cursor:pointer; border:1px solid var(--border); background:#f3f6fd; color:var(--ink); padding:10px 14px; border-radius:10px; font-weight:600; transition:.15s transform ease,.15s background-color ease,.15s border-color ease;}
  button:hover{transform:translateY(-1px); background:#eef3ff; border-color:#cfd9ee}
  main{max-width:1100px; margin:0 auto; padding:0 16px 28px}
  .card{position:relative; background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:18px; box-shadow:0 8px 24px rgba(12,22,44,.06)}
  .stage{display:grid; grid-template-columns:1fr 260px; gap:16px; align-items:start}
  @media (max-width:980px){ .stage{grid-template-columns:1fr} }
  .plotWrap{background:#fff; border:1px solid var(--border); border-radius:12px; padding:8px; min-height:420px; position:relative}
  .plotWrap svg{width:100%; height:420px; display:block; background:#fff; border-radius:8px}
  .legend{display:grid; grid-template-columns:1fr; gap:8px; background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px;}
  .legend h3{margin:0 0 8px; font-size:14px; color:var(--muted)}
  .pill{display:flex; gap:8px; align-items:center; padding:8px 10px; background:#fbfdff; border:1px solid var(--border); border-radius:10px}
  .dot{width:12px; height:12px; border-radius:50%}
  .answers{margin-top:14px; padding:10px; background:#fbfdff; border:1px solid var(--border); border-radius:10px; display:none}
  .answers.show{display:block}
  .answers ul{margin:8px 0 0 18px}
  .toast{position:fixed; z-index:50; right:14px; bottom:14px; padding:10px 12px; border-radius:10px; background:#ffffff; border:1px solid var(--border); color:var(--ink); font-weight:600; box-shadow:0 10px 30px rgba(0,0,0,.08); opacity:0; transform:translateY(10px); transition:.2s opacity ease,.2s transform ease}
  .toast.show{opacity:1; transform:none}
  footer{opacity:.7; text-align:center; font-size:12px; padding:10px}
</style>
</head>
<body>
<header>
  <div>
    <h1>Graph Blitz</h1>
    <div class="instructions">How to play: Colours are fixed per family (see Legend). If any graphed family uses its own colour, grab that family. Otherwise, grab the single family that is completely absent (neither its graph nor its colour appears).</div>
  </div>
  <div class="controls">
    <button id="btn-new">New card</button>
    <button id="btn-solution">Show solution</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="stage">
      <div class="plotWrap">
        <svg id="plot" viewBox="0 0 900 520" preserveAspectRatio="xMidYMid meet" aria-label="Graph plot area"></svg>
      </div>
      <aside class="legend" id="legend">
        <h3>Legend</h3>
      </aside>
    </div>

    <div class="answers" id="answers">
      <strong>Grab:</strong>
      <ul id="answerList"></ul>
    </div>
  </div>
</main>

<div class="toast" id="toast">New card generated</div>
<footer>GitHub Pages friendly â€” single file.</footer>

<script>
(function(){
  /* ---------- Fixed mapping (like Ghost Blitz pieces) ---------- */
  const FAMILY = [
    { key:'lin',   name:'Linear',      color:'ccyan'    },
    { key:'quad',  name:'Quadratic',   color:'cgreen'   },
    { key:'sin',   name:'Sinusoidal',  color:'black'    },
    { key:'recip', name:'Reciprocal',  color:'cblue'    },
    { key:'exp',   name:'Exponential', color:'cmagenta' },
    { key:'rad',   name:'Radical',     color:'corange'  },
    { key:'cub',   name:'Degree 3',    color:'cred'     },
  ];
  const KEY = Object.fromEntries(FAMILY.map(f=>[f.key,f]));
  const COLOR_HEX = { ccyan:css('--ccyan'), cgreen:css('--cgreen'), black:css('--cblack'), cblue:css('--cblue'), cmagenta:css('--cmagenta'), corange:css('--corange'), cred:css('--cred') };

  /* ---------- Utilities ---------- */
  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  function sample(arr,k){ const a=[...arr], r=[]; for(let i=0;i<k;i++){ const j=Math.floor(Math.random()*a.length); r.push(a.splice(j,1)[0]); } return r; }
  function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

  /* ---------- Plot (SVG) with transformable families ---------- */
  const PLOT = document.getElementById('plot');
  const W=900,H=520,PAD=40; const XMIN=-3,XMAX=3,YMIN=-3,YMAX=3;
  const sx = x => PAD + (x-XMIN)/(XMAX-XMIN)*(W-2*PAD);
  const sy = y => H - PAD - (y-YMIN)/(YMAX-YMIN)*(H-2*PAD);
  function mk(tag, attrs={}, kids=[]){ const el=document.createElementNS('http://www.w3.org/2000/svg',tag); Object.entries(attrs).forEach(([k,v])=>el.setAttribute(k,v)); kids.forEach(ch=>el.appendChild(ch)); return el; }
  function axes(){ const g=mk('g'); const x0=sy(0), y0=sx(0); g.appendChild(mk('line',{x1:sx(XMIN),y1:x0,x2:sx(XMAX),y2:x0,stroke:'#444'})); g.appendChild(mk('line',{x1:y0,y1:sy(YMIN),x2:y0,y2:sy(YMAX),stroke:'#444'})); for(let t=-3;t<=3;t++){ const tx=sx(t), ty=sy(t); g.appendChild(mk('line',{x1:tx,y1:x0-4,x2:tx,y2:x0+4,stroke:'#aaa'})); g.appendChild(mk('line',{x1:y0-4,y1:ty,x2:y0+4,y2:ty,stroke:'#aaa'})); } return g; }
  function pathFor(fn, segs, color, width=3){ const N=700; let d=''; for(const [a,b] of segs){ let first=true; for(let i=0;i<=N;i++){ const x=a+(b-a)*i/N; let y=fn(x); if(!isFinite(y)) { first=true; continue; } y=Math.max(YMIN-1,Math.min(YMAX+1,y)); const px=sx(x).toFixed(2), py=sy(y).toFixed(2); d += (first?`M ${px} ${py}`:` L ${px} ${py}`); first=false; } } return mk('path',{d,fill:'none',stroke:color,'stroke-width':String(width)}); }

  // Random transform helpers (keep curves varied but readable)
  function rng(a,b){ return a + Math.random()*(b-a); }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function familyFn(key){
    switch(key){
      case 'lin': {
        const m = pick([-2,-1.5,-1,-0.5,0.5,1,1.5,2]);
        const h = rng(-1.5,1.5), k = rng(-1.0,1.0);
        const fn = x => m*(x-h)+k;
        return { fn, segs:[[-3,3]] };
      }
      case 'quad': {
        const a = pick([-1.5,-1,-0.7,0.7,1,1.3]);
        const h = rng(-1.0,1.0), k = rng(-0.8,1.0);
        const fn = x => a*(x-h)*(x-h)+k;
        return { fn, segs:[[-3,3]] };
      }
      case 'sin': {
        const A = pick([0.7,1,1.3]) * pick([1,-1]);
        const B = pick([0.7,1,1.4]);
        const h = rng(-1.5,1.5), k = rng(-0.5,0.5);
        const fn = x => A*Math.sin(B*(x-h))+k;
        return { fn, segs:[[-6.283,6.283]] };
      }
      case 'recip': {
        const A = pick([0.8,1,1.5]) * pick([1,-1]);
        const h = rng(-0.8,0.8), k = rng(-0.8,0.8);
        const fn = x => A/(x-h)+k;
        return { fn, segs:[[-3,h-0.2],[h+0.2,3]] };
      }
      case 'exp': {
        const A = pick([0.3,0.5,0.8]) * pick([1,-1]);
        const B = pick([0.6,0.8,1.0]);
        const h = rng(-0.8,0.8), k = rng(-0.5,0.8);
        const fn = x => A*Math.exp(B*(x-h))+k;
        return { fn, segs:[[-3,3]] };
      }
      case 'rad': {
        const A = pick([0.7,1,1.3]) * pick([1,-1]);
        const h = rng(-2.0,1.5), k = rng(-0.8,0.8);
        const fn = x => A*Math.sqrt(Math.max(0,x-h))+k;
        return { fn, segs:[[h,3]] };
      }
      case 'cub': {
        const A = pick([0.5,0.8,1,1.3]) * pick([1,-1]);
        const h = rng(-1.2,1.2), k = rng(-1.0,1.0);
        const fn = x => A*Math.pow(x-h,3)+k;
        return { fn, segs:[[-3,3]] };
      }
    }
  }

  function renderPlot(curves){
    PLOT.innerHTML='';
    PLOT.appendChild(axes());
    for(const c of curves){
      const col = COLOR_HEX[KEY[c.colorK].color];
      const f   = familyFn(c.shapeK);
      PLOT.appendChild(pathFor(f.fn, f.segs, col));
    }
  }

  /* ---------- Legend (single column, one per family) ---------- */
  const legend = document.getElementById('legend');
  function makeLegend(){
    legend.querySelectorAll('.pill').forEach(n=>n.remove());
    FAMILY.forEach(f=>{
      const p=document.createElement('div'); p.className='pill';
      const dot=document.createElement('span'); dot.className='dot'; dot.style.background=COLOR_HEX[f.color];
      const text=document.createElement('span'); text.textContent=f.name;
      p.append(dot,text); legend.appendChild(p);
    });
  }

  /* ---------- Solution box ---------- */
  const ansWrap = document.getElementById('answers');
  const ansList = document.getElementById('answerList');
  function showSolution(item){
    ansList.innerHTML='';
    const li=document.createElement('li'); const hex = COLOR_HEX[KEY[item].color];
    li.innerHTML = `<span class="dot" style="background:${hex}; display:inline-block; vertical-align:middle; margin-right:6px"></span><strong>${KEY[item].name}</strong>`;
    ansList.appendChild(li); ansWrap.classList.add('show');
  }
  function hideSolution(){ ansWrap.classList.remove('show'); ansList.innerHTML=''; }

  /* ---------- Helpers for always-unique card ---------- */
  function derangeColours(shapes, colours){
    // Assign each shape a colour with colour != shape. Simple backtracking.
    const n = shapes.length; const used = Array(n).fill(false); const out = Array(n).fill(null);
    function backtrack(i){
      if(i===n) return true;
      for(let j=0;j<n;j++){
        if(used[j]) continue;
        const c = colours[j];
        if(c===shapes[i]) continue;
        out[i]=c; used[j]=true;
        if(backtrack(i+1)) return true;
        used[j]=false; out[i]=null;
      }
      return false;
    }
    if(backtrack(0)) return out; else return null;
  }

  /* ---------- Card generation (graphs only, always-solvable) ---------- */
  function makeCard(){
    const all = FAMILY.map(f=>f.key);
    const shapes = sample(all, 4).sort();           // families drawn as graphs
    const absent = all.filter(k=>!shapes.includes(k)); // the other 3 families

    let curves = []; // list of {shapeK, colorK}
    let solution = null;

    if (Math.random() < 0.5){
      // MATCH TYPE: exactly one graph drawn in its canonical colour
      const matchK = rand(shapes);
      const others = shapes.filter(k=>k!==matchK);
      // colours to assign: one correct, others mismatched
      let colours = [matchK, ...others.map(s=>rand(all.filter(k=>k!==s)) )];
      // Ensure at least the mismatches are not accidentally equal
      let assigned = derangeColours(shapes, colours);
      if(!assigned){ return makeCard(); }
      for(let i=0;i<shapes.length;i++) curves.push({ shapeK: shapes[i], colorK: assigned[i] });
      // Force exactly one correct: if assigned doesn't keep match unique, rebuild
      const correctCount = curves.filter(c=>c.shapeK===c.colorK).length;
      if (correctCount!==1){ return makeCard(); }
      solution = matchK;
    } else {
      // ABSENT TYPE: zero correctly-coloured graphs
      // choose a unique fully-absent family whose SHAPE and COLOUR both do not appear
      const [absPick, b, c] = shuffle([...absent]);
      // prepare colours list: must include b and c (so they are not fully absent), exclude absPick
      let colourCandidates = [b, c];
      // fill to 4 with colours from shapes (allow repeats avoidance)
      while(colourCandidates.length < 4){
        const k = rand(shapes);
        if(!colourCandidates.includes(k)) colourCandidates.push(k);
      }
      // remove any accidental absPick
      colourCandidates = colourCandidates.filter(k=>k!==absPick);
      while(colourCandidates.length<4){
        const k = rand(all.filter(x=>x!==absPick));
        if(!colourCandidates.includes(k)) colourCandidates.push(k);
      }
      // Find a derangement assignment so no shape gets its own colour
      let assigned = derangeColours(shapes, shuffle(colourCandidates));
      if(!assigned){ return makeCard(); }
      for(let i=0;i<shapes.length;i++) curves.push({ shapeK: shapes[i], colorK: assigned[i] });
      // Validate constraints
      const anyCorrect = curves.some(c=>c.shapeK===c.colorK);
      const colorsUsed = new Set(curves.map(c=>c.colorK));
      if (anyCorrect) return makeCard();
      if (colorsUsed.has(absPick)) return makeCard();
      // Ensure b or c colours appear so they are not fully absent
      if (!(colorsUsed.has(b) && colorsUsed.has(c))) return makeCard();
      solution = absPick; // unique fully-absent
    }

    curves = shuffle(curves); // randomize draw order

    return { curves, solution };
  }

  function render(){
    const {curves, solution} = makeCard();
    renderPlot(curves);
    makeLegend();
    hideSolution();
    // store for solution button
    render.currentSolution = solution;
  }

  /* ---------- App wiring ---------- */
  document.getElementById('btn-new').addEventListener('click', render);
  document.getElementById('btn-solution').addEventListener('click', ()=>{
    if (render.currentSolution) showSolution(render.currentSolution);
  });

  // Boot
  makeLegend();
  render();
})();
</script>
</body>
</html>
