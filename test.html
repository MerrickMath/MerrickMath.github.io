<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Graph Blitz</title>
<style>
  :root{
    /* Light theme */
    --bg:#f7f9fc; --ink:#0b1220; --muted:#5a6c8f; --panel:#ffffff; --border:#dde3f0;
    --clin:#ff0000; --cquad:#ff8000; --csin:#111111; --crecip:#0099ff; --cexp:#ff66cc; --crad:#ffff00; --ccub:#009900;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif; color:var(--ink); background:var(--bg)}
  header{padding:20px 16px; display:flex; gap:12px; align-items:center; justify-content:space-between; max-width:1100px; margin:0 auto; flex-wrap:wrap;}
  h1{margin:0; font-size:22px; letter-spacing:.3px; font-weight:700}
  .instructions{font-size:13px;color:var(--muted);background:#fbfdff;border:1px solid var(--border);border-radius:8px;padding:8px 10px;margin-top:6px;max-width:700px}
  .controls{display:flex; gap:10px; flex-wrap:wrap}
  button{cursor:pointer; border:1px solid var(--border); background:#f3f6fd; color:var(--ink); padding:10px 14px; border-radius:10px; font-weight:600; transition:.15s transform ease,.15s background-color ease,.15s border-color ease;}
  button:hover{transform:translateY(-1px); background:#eef3ff; border-color:#cfd9ee}
  main{max-width:1100px; margin:0 auto; padding:0 16px 28px}
  .card{position:relative; background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:18px; box-shadow:0 8px 24px rgba(12,22,44,.06)}
  .stage{display:grid; grid-template-columns:1fr 260px; gap:16px; align-items:start}
  @media (max-width:980px){ .stage{grid-template-columns:1fr} }
  .plotWrap{background:#fff; border:1px solid var(--border); border-radius:12px; padding:8px; min-height:420px; position:relative}
  .plotWrap svg{width:100%; height:420px; display:block; background:#fff; border-radius:8px}
  .legend{display:grid; grid-template-columns:1fr; gap:8px; background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px;}
  .legend h3{margin:0 0 8px; font-size:14px; color:var(--muted)}
  .pill{display:flex; gap:8px; align-items:center; padding:8px 10px; background:#fbfdff; border:1px solid var(--border); border-radius:10px}
  .dot{width:12px; height:12px; border-radius:50%}
  .answers{margin-top:14px; padding:10px; background:#fbfdff; border:1px solid var(--border); border-radius:10px; display:none}
  .answers.show{display:block}
  .answers ul{margin:8px 0 0 18px}
  .toast{position:fixed; z-index:50; right:14px; bottom:14px; padding:10px 12px; border-radius:10px; background:#ffffff; border:1px solid var(--border); color:var(--ink); font-weight:600; box-shadow:0 10px 30px rgba(0,0,0,.08); opacity:0; transform:translateY(10px); transition:.2s opacity ease,.2s transform ease}
  .toast.show{opacity:1; transform:none}
  footer{opacity:.7; text-align:center; font-size:12px; padding:10px}
</style>
</head>
<body>
<header>
  <div>
    <h1>Graph Blitz</h1>
    <div class="instructions">How to play: Colours are fixed per family (see Legend). If any graphed family uses its own colour, grab that family. Otherwise, grab the single family that is completely absent (neither its graph nor its colour appears).</div>
  </div>
  <div class="controls">
    <button id="btn-new">New card</button>
    <button id="btn-solution">Show solution</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="stage">
      <div class="plotWrap">
        <svg id="plot" viewBox="0 0 900 520" preserveAspectRatio="xMidYMid meet" aria-label="Graph plot area"></svg>
      </div>
      <aside class="legend" id="legend">
        <h3>Legend</h3>
      </aside>
    </div>

    <div class="answers" id="answers">
      <strong>Grab:</strong>
      <ul id="answerList"></ul>
    </div>
  </div>
</main>

<div class="toast" id="toast">New card generated</div>
<footer id="site-footer">Math with Mr. Merrick</footer>

<script>
(function(){
  /* ---------- Fixed mapping (updated colours) ---------- */
  const FAMILY = [
    { key:'lin',   name:'Linear',      color:'clin'    }, // Red
    { key:'quad',  name:'Quadratic',   color:'cquad'   }, // Orange
    { key:'sin',   name:'Sinusoidal',  color:'csin'    }, // Black
    { key:'recip', name:'Reciprocal',  color:'crecip'  }, // Light Blue (#0099FF)
    { key:'exp',   name:'Exponential', color:'cexp'    }, // Pink
    { key:'rad',   name:'Radical',     color:'crad'    }, // Yellow
    { key:'cub',   name:'Degree 3 Polynomial', color:'ccub' }, // Green
  ];
  const KEY = Object.fromEntries(FAMILY.map(f=>[f.key,f]));
  const COLOR_HEX = {
    clin:css('--clin'), cquad:css('--cquad'), csin:css('--csin'), crecip:css('--crecip'),
    cexp:css('--cexp'), crad:css('--crad'), ccub:css('--ccub')
  };
  const ALL_KEYS = FAMILY.map(f=>f.key);

  /* ---------- Utilities ---------- */
  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  function sample(arr,k){ const a=[...arr], r=[]; for(let i=0;i<k;i++){ const j=Math.floor(Math.random()*a.length); r.push(a.splice(j,1)[0]); } return r; }
  function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

  /* ---------- Plot (SVG) with transformable families ---------- */
  const PLOT = document.getElementById('plot');
  const W=900,H=520,PAD=40; const XMIN=-3,XMAX=3,YMIN=-3,YMAX=3;
  const sx = x => PAD + (x-XMIN)/(XMAX-XMIN)*(W-2*PAD);
  const sy = y => H - PAD - (y-YMIN)/(YMAX-YMIN)*(H-2*PAD);
  function mk(tag, attrs={}, kids=[]){ const el=document.createElementNS('http://www.w3.org/2000/svg',tag); Object.entries(attrs).forEach(([k,v])=>el.setAttribute(k,v)); kids.forEach(ch=>el.appendChild(ch)); return el; }
  function axes(){ const g=mk('g'); const x0=sy(0), y0=sx(0); g.appendChild(mk('line',{x1:sx(XMIN),y1:x0,x2:sx(XMAX),y2:x0,stroke:'#444'})); g.appendChild(mk('line',{x1:y0,y1:sy(YMIN),x2:y0,y2:sy(YMAX),stroke:'#444'})); for(let t=-3;t<=3;t++){ const tx=sx(t), ty=sy(t); g.appendChild(mk('line',{x1:tx,y1:x0-4,x2:tx,y2:x0+4,stroke:'#aaa'})); g.appendChild(mk('line',{x1:y0-4,y1:ty,x2:y0+4,y2:ty,stroke:'#aaa'})); } return g; }
  function pathFor(fn, segs, color, width=3){ const N=700; let d=''; for(const [a,b] of segs){ let first=true; for(let i=0;i<=N;i++){ const x=a+(b-a)*i/N; let y=fn(x); if(!isFinite(y)) { first=true; continue; } y=Math.max(YMIN-1,Math.min(YMAX+1,y)); const px=sx(x).toFixed(2), py=sy(y).toFixed(2); d += (first?`M ${px} ${py}`:` L ${px} ${py}`); first=false; } } return mk('path',{d,fill:'none',stroke:color,'stroke-width':String(width)}); }

  // Random transform helpers (keep curves varied but readable)
  function rng(a,b){ return a + Math.random()*(b-a); }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function familyFn(key){
    switch(key){
      case 'lin': {
        const m = pick([-2,-1.5,-1,-0.5,0.5,1,1.5,2]);
        const h = rng(-1.5,1.5), k = rng(-1.0,1.0);
        const fn = x => m*(x-h)+k;
        return { fn, segs:[[-3,3]] };
      }
      case 'quad': {
        const a = pick([-1.3,-1,-0.7,0.7,1,1.3]);
        const h = rng(-1.0,1.0), k = rng(-0.8,1.0);
        const fn = x => a*(x-h)*(x-h)+k;
        return { fn, segs:[[-3,3]] };
      }
      case 'sin': {
        const A = pick([0.7,1,1.3]) * pick([1,-1]);
        const B = pick([0.7,1,1.4]);
        const h = rng(-1.5,1.5), k = rng(-0.5,0.5);
        const fn = x => A*Math.sin(B*(x-h))+k;
        return { fn, segs:[[-6.283,6.283]] };
      }
      case 'recip': {
        const A = pick([0.8,1,1.5]) * pick([1,-1]);
        const h = rng(-0.8,0.8), k = rng(-0.8,0.8);
        const fn = x => A/(x-h)+k;
        return { fn, segs:[[-3,h-0.2],[h+0.2,3]] };
      }
      case 'exp': {
        const A = pick([0.3,0.5,0.8]) * pick([1,-1]);
        const B = pick([0.6,0.8,1.0]);
        const h = rng(-0.8,0.8), k = rng(-0.5,0.8);
        const fn = x => A*Math.exp(B*(x-h))+k;
        return { fn, segs:[[-3,3]] };
      }
      case 'rad': {
        const A = pick([0.7,1,1.3]) * pick([1,-1]);
        const h = rng(-2.0,1.5), k = rng(-0.8,0.8);
        const fn = x => A*Math.sqrt(Math.max(0,x-h))+k;
        return { fn, segs:[[h,3]] };
      }
      case 'cub': {
        const A = pick([0.5,0.8,1,1.3]) * pick([1,-1]);
        const h = rng(-1.2,1.2), k = rng(-1.0,1.0);
        const fn = x => A*Math.pow(x-h,3)+k;
        return { fn, segs:[[-3,3]] };
      }
    }
  }

  function renderPlot(curves){
    PLOT.innerHTML='';
    PLOT.appendChild(axes());
    for(const c of curves){
      const col = COLOR_HEX[KEY[c.colorK].color];
      const f   = familyFn(c.shapeK);
      PLOT.appendChild(pathFor(f.fn, f.segs, col));
    }
  }

  /* ---------- Legend (single column, updated text) ---------- */
  const legend = document.getElementById('legend');
  const LEGEND_TEXT = {
    lin: 'Linear — Red',
    quad: 'Quadratic — Orange',
    sin: 'Sinusoidal — Black',
    recip: 'Reciprocal — Light Blue',
    exp: 'Exponential — Pink',
    rad: 'Radical — Yellow',
    cub: 'Degree 3 Polynomial — Green'
  };
  function makeLegend(){
    legend.querySelectorAll('.pill').forEach(n=>n.remove());
    FAMILY.forEach(f=>{
      const p=document.createElement('div'); p.className='pill';
      const dot=document.createElement('span'); dot.className='dot'; dot.style.background=COLOR_HEX[f.color];
      const text=document.createElement('span'); text.textContent = LEGEND_TEXT[f.key] || f.name;
      p.append(dot,text); legend.appendChild(p);
    });
  }

  /* ---------- Derangement helper ---------- */
  function derange(shapes, colours){
    // assign colours (array of family keys) to shapes (array of family keys) such that colour != corresponding shape
    const n=shapes.length; const used=Array(n).fill(false); const out=Array(n).fill(null);
    function backtrack(i){
      if(i===n) return true;
      for(let j=0;j<n;j++){
        if(used[j]) continue; const c=colours[j]; if(c===shapes[i]) continue;
        out[i]=c; used[j]=true; if(backtrack(i+1)) return true; used[j]=false; out[i]=null;
      }
      return false;
    }
    return backtrack(0) ? out : null;
  }

  /* ---------- Card generation (graphs only, always-solvable, stricter) ---------- */
  function makeCard(){
    const shapes = sample(ALL_KEYS, 4).sort();            // families drawn as graphs
    const absent = ALL_KEYS.filter(k=>!shapes.includes(k));

    let curves = []; // list of {shapeK, colorK}
    let solution = null;

    // helper: count fully-absent families (neither shape nor colour appears)
    const countFullyAbsent = (curves)=>{
      const shapeSet = new Set(shapes);
      const colourSet = new Set(curves.map(c=>c.colorK));
      return ALL_KEYS.filter(k=>!shapeSet.has(k) && !colourSet.has(k));
    };

    if (Math.random() < 0.5){
      // MATCH TYPE: exactly one graph drawn in its canonical colour AND no family is fully absent
      const matchK = rand(shapes);
      const othersIdx = shapes.map((s,i)=>({s,i})).filter(o=>o.s!==matchK);

      // Colours to use: matchK plus ALL three absent families → ensures 0 fully-absent
      const colourOptions = [matchK, ...absent];

      // Backtracking assignment with a lock (match graph must take its own colour)
      const out = Array(shapes.length).fill(null);
      const used = Array(colourOptions.length).fill(false);
      const lockIndex = shapes.indexOf(matchK);
      out[lockIndex] = matchK; used[0] = true; // matchK is at colourOptions[0]

      function backtrack(pos){
        if (pos===shapes.length) return true;
        if (pos===lockIndex) return backtrack(pos+1);
        for (let j=1; j<colourOptions.length; j++){
          if (used[j]) continue;
          const c = colourOptions[j];
          if (c===shapes[pos]) continue; // derangement for others
          used[j]=true; out[pos]=c;
          if (backtrack(pos+1)) return true;
          used[j]=false; out[pos]=null;
        }
        return false;
      }

      if (!backtrack(0)) return makeCard();

      for (let i=0;i<shapes.length;i++) curves.push({ shapeK: shapes[i], colorK: out[i] });

      // Strict validation
      const correctCount = curves.filter(c=>c.shapeK===c.colorK).length;
      const fullyAbsent = countFullyAbsent(curves);
      if (correctCount!==1 || fullyAbsent.length!==0){
        return makeCard();
      }
      solution = matchK;
    } else {
      // ABSENT TYPE: zero correctly-coloured graphs; exactly one fully-absent family
      const absPick = rand(absent);
      const remainingAbsent = absent.filter(k=>k!==absPick);

      // Build colour set: include the other two absent families so they are NOT fully absent, exclude absPick
      let colourCandidates = shuffle([ ...remainingAbsent, ...shapes ]);
      colourCandidates = Array.from(new Set(colourCandidates.filter(k=>k!==absPick))).slice(0,4);
      while(colourCandidates.length<4){
        const k = rand(ALL_KEYS.filter(x=>x!==absPick && !colourCandidates.includes(x)));
        colourCandidates.push(k);
      }

      const assigned = derange(shapes, colourCandidates);
      if(!assigned) return makeCard();
      for(let i=0;i<shapes.length;i++) curves.push({ shapeK: shapes[i], colorK: assigned[i] });

      // Strict validation
      const anyCorrect = curves.some(c=>c.shapeK===c.colorK);
      if (anyCorrect) return makeCard();
      const fullyAbsent = countFullyAbsent(curves);
      if (fullyAbsent.length!==1 || fullyAbsent[0]!==absPick){
        return makeCard();
      }
      solution = absPick;
    }

    curves = shuffle(curves); // randomize draw order
    return { curves, solution };
  }

  /* ---------- Derive all solutions from what's drawn ---------- */
  function computeSolutions(curves){
    const shapesSet = new Set(curves.map(c=>c.shapeK));
    const colorsSet = new Set(curves.map(c=>c.colorK));
  
    // If any graphed family uses its own colour, all of those are valid grabs
    const correctlyColoured = Array.from(new Set(
      curves.filter(c=>c.shapeK === c.colorK).map(c=>c.shapeK)
    ));
  
    if (correctlyColoured.length > 0){
      return correctlyColoured; // Multiple are all acceptable
    }
  
    // Otherwise: families that are completely absent (neither graphed nor coloured)
    const fullyAbsent = ALL_KEYS.filter(k => !shapesSet.has(k) && !colorsSet.has(k));
    return fullyAbsent; // Could be 1 (usually) or more (edge cases)
  }

  
  /* ---------- Solution box ---------- */
  const ansWrap = document.getElementById('answers');
  const ansList = document.getElementById('answerList');
  function showSolution(keys){
    ansList.innerHTML = '';
    const uniq = Array.from(new Set(keys)); // de-dupe just in case
    uniq.forEach(key=>{
      const fam = KEY[key];
      const hex = COLOR_HEX[fam.color];
      const li = document.createElement('li');
      li.innerHTML = `<span class="dot" style="background:${hex}; display:inline-block; vertical-align:middle; margin-right:6px"></span><strong>${fam.name}</strong>`;
      ansList.appendChild(li);
    });
    ansWrap.classList.add('show');
  }
  function hideSolution(){ ansWrap.classList.remove('show'); ansList.innerHTML=''; }

  function toast(msg){ const t=document.getElementById('toast'); if(!t) return; t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200); }

  /* ---------- App wiring ---------- */
  function newCard(){
    const {curves} = makeCard();
    renderPlot(curves);
    makeLegend();
    hideSolution();
    newCard.curves = curves; // store for on-demand solution calc
    toast('New card generated');
  }
  
  document.getElementById('btn-new').addEventListener('click', newCard);
  document.getElementById('btn-solution').addEventListener('click', ()=>{
    const sols = computeSolutions(newCard.curves || []);
    showSolution(sols);
  });
  
  // Boot
  makeLegend();
  newCard();
  })();
</script>
</body>
</html>
