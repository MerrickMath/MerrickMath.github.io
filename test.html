<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camel Up – Interactive Leg Completer</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#f6f8fb;color:#0d1b2a;margin:0}
    .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
    .card{background:#fff;border:1px solid #d8e0ef;border-radius:12px;padding:16px;margin-bottom:16px;box-shadow:0 4px 10px rgba(13,27,42,.05)}
    h1{margin:0 0 6px}
    .subtitle{color:#5b6b88;margin:0 0 14px}
    .track{display:grid;grid-template-columns:repeat(var(--len),26px);gap:4px;align-items:end;margin-bottom:12px}
    .space{height:84px;background:#fff;border:1px dashed #d8e0ef;border-radius:8px;display:flex;flex-direction:column-reverse;align-items:center;justify-content:flex-start;padding:4px}
    .camel{width:18px;height:12px;border-radius:3px;border:1px solid rgba(0,0,0,.15);margin:2px 0}
    .camel.crazy{outline:2px dashed #000;outline-offset:1px}
    .row{display:grid;grid-template-columns:160px 1fr;gap:10px;align-items:center;padding:6px 0}
    .legend{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;margin-top:10px}
    .controls{margin-top:12px;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .controls input{width:110px}
    input[type=number], select{background:#fff;border:1px solid #d8e0ef;border-radius:10px;padding:8px}
    input[type=number]:focus, select:focus{outline:2px solid #93c5fd;border-color:#93c5fd}
    button{cursor:pointer;background:linear-gradient(180deg,#93c5fd,#60a5fa);color:#05152b;font-weight:800;border:none;padding:10px 14px;border-radius:10px}
    table{border-collapse:collapse;width:100%}
    th,td{border-bottom:1px solid #d8e0ef;padding:6px 8px;text-align:center}
    .mono{font-variant-numeric:tabular-nums}
    .note{font-size:12px;color:#5b6b88}
    .nowrap{white-space:nowrap}
    .scroller{max-height:360px;overflow:auto}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#eef2ff;border:1px solid #c7d2fe;font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block}
    .error{color:#b91c1c}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Camel Up – Interactive Leg Completer</h1>
  <p class="subtitle">Math with Mr. Merrick</p>
  <p class="subtitle">Enter a sequence of die results (e.g., <i>Red moves 2</i>), and the app simulates the remainder of the leg after each input. Stats update live. Reset anytime.</p>

  <!-- Setup (reused) -->
  <section class="card" id="setup">
    <h2>Setup</h2>
    <div id="board" class="track" style="--len:16"></div>

    <div class="row"><strong>Track length</strong><input id="trackLen" type="number" value="16" min="6" max="40" /></div>
    <div class="row"><strong>Simulations per step</strong><input id="sims" type="number" value="500" min="1" max="100000" /></div>

    <h3>Racing camels</h3>
    <div id="rows-racers"></div>

    <h3>Crazy camels</h3>
    <div id="rows-crazy"></div>

    <div class="legend">
      <span class="pill"><span class="dot" style="background:#3b82f6"></span> Blue</span>
      <span class="pill"><span class="dot" style="background:#22c55e"></span> Green</span>
      <span class="pill"><span class="dot" style="background:#ef4444"></span> Red</span>
      <span class="pill"><span class="dot" style="background:#eab308"></span> Yellow</span>
      <span class="pill"><span class="dot" style="background:#a855f7"></span> Purple</span>
      <span class="pill"><span class="dot" style="background:#111827"></span> Black (crazy)</span>
      <span class="pill"><span class="dot" style="background:#f8fafc;border:1px solid #cbd5e1"></span> White (crazy)</span>
    </div>
    <p class="note">At equal start spaces, stacks are auto-ordered: racers on the bottom (Blue→Purple), crazy on top (Black→White).</p>
  </section>

  <!-- Interactive inputs for this leg -->
  <section class="card" id="interactive">
    <h2>Enter die results</h2>
    <div class="controls">
      <label>Die
        <select id="dieSelect">
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="red">Red</option>
          <option value="yellow">Yellow</option>
          <option value="purple">Purple</option>
          <option value="grey">Grey</option>
        </select>
      </label>
      <label>Moves
        <select id="moveSelect">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
        </select>
      </label>
      <button id="applyBtn">Apply move</button>
      <button id="undoBtn" title="Undo last input">Undo</button>
      <button id="resetBtn" title="Reset the leg to setup state">Reset</button>
      <span class="note" id="status"></span>
    </div>

    <div style="margin-top:10px" id="usedDiceLine" class="note">No inputs yet.</div>
  </section>

  <section class="card">
    <h2>Placement stats (after completing the leg from current state)</h2>
    <div id="placementStats">Make an input to see stats…</div>
  </section>
</div>

<script>
(function(){
  // === Config ===
  const RACERS=[
    {id:'blue',name:'Blue',color:'#3b82f6'},
    {id:'green',name:'Green',color:'#22c55e'},
    {id:'red',name:'Red',color:'#ef4444'},
    {id:'yellow',name:'Yellow',color:'#eab308'},
    {id:'purple',name:'Purple',color:'#a855f7'}
  ];
  const CRAZY=[
    {id:'black',name:'Black (crazy)',color:'#111827',crazy:true},
    {id:'white',name:'White (crazy)',color:'#f8fafc',border:'#cbd5e1',crazy:true},
  ];
  const CAMELS=[...RACERS,...CRAZY];

  // === Utils ===
  const el=s=>document.querySelector(s);
  const make=(t,p={})=>Object.assign(document.createElement(t),p);
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const isCrazyId=cid=>CRAZY.some(c=>c.id===cid);
  const shuffle=(arr)=>{ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };

  // === Build Setup Rows ===
  function buildRows(){
    const rowsR=el('#rows-racers'); const rowsC=el('#rows-crazy');
    rowsR.innerHTML=''; rowsC.innerHTML='';

    rowsR.appendChild(make('div',{className:'row',innerHTML:'<div><b>Camel</b></div><div><b>Start space</b></div>'}));
    RACERS.forEach(c=>{
      const row=make('div',{className:'row'});
      row.append(
        make('div',{innerHTML:`<span style="font-weight:700;color:${c.color}">${c.name}</span>`}),
        make('input',{type:'number',min:1,max:100,step:1,value:1,id:`pos-${c.id}`})
      );
      rowsR.appendChild(row);
    });

    rowsC.appendChild(make('div',{className:'row',innerHTML:'<div><b>Camel</b></div><div><b>Spaces from finish (1 = last space)</b></div>'}));
    CRAZY.forEach(c=>{
      const row=make('div',{className:'row'});
      row.append(
        make('div',{innerHTML:`<span style="font-weight:700;${c.crazy?`color:${c.color}`:''}">${c.name}</span>`}),
        make('input',{type:'number',min:1,max:100,step:1,value:1,id:`pos-${c.id}`})
      );
      rowsC.appendChild(row);
    });
  }

  // === Board helpers ===
  function buildInitialBoard(){
    const trackLen=clamp(parseInt(el('#trackLen')?.value||16,10),6,40);
    const groups=new Map();

    RACERS.forEach(c=>{
      const s=parseInt(el(`#pos-${c.id}`)?.value||1,10);
      const space=clamp(s-1,0,trackLen-1);
      if(!groups.has(space)) groups.set(space,[]);
      groups.get(space).push({camel:c.id,crazy:false});
    });
    CRAZY.forEach(c=>{
      const f=parseInt(el(`#pos-${c.id}`)?.value||1,10);
      const space=clamp(trackLen - f, 0, trackLen-1);
      if(!groups.has(space)) groups.set(space,[]);
      groups.get(space).push({camel:c.id,crazy:true});
    });

    const board=new Map();
    for(const [space,arr] of groups.entries()){
      arr.sort((a,b)=>{
        const ag=a.crazy?1:0, bg=b.crazy?1:0; if(ag!==bg) return ag-bg;
        const idx=x=> x.crazy ? CRAZY.findIndex(y=>y.id===x.camel) : RACERS.findIndex(y=>y.id===x.camel);
        return idx(a)-idx(b);
      });
      board.set(space, arr.map(x=>x.camel)); // bottom->top
    }
    return board;
  }

  function drawBoard(board){
    const trackLen=parseInt(el('#trackLen')?.value,10)||16;
    const boardEl=el('#board'); boardEl.style.setProperty('--len',String(trackLen)); boardEl.innerHTML='';
    for(let s=0;s<trackLen;s++){
      const cell=make('div',{className:'space'});
      const stack=board.get(s)||[];
      stack.forEach(cid=>{
        const cfg=CAMELS.find(x=>x.id===cid);
        const cam=make('div',{className:'camel'+(cfg?.crazy?' crazy':''),title:cfg?.name||cid});
        if(cfg){ cam.style.background=cfg.color; if(cfg.border) cam.style.borderColor=cfg.border; }
        cell.appendChild(cam);
      });
      boardEl.appendChild(cell);
    }
  }

  function locate(board,camel){ for(const[s,stack] of board.entries()){ const i=stack.indexOf(camel); if(i!==-1) return {space:s,index:i}; } return {space:-1,index:-1}; }
  function positionsFromBoard(board){ const pos=new Map(); for(const[s,stack] of board.entries()){ for(let i=0;i<stack.length;i++){ pos.set(stack[i], s); } } return pos; }
  function placementsFromBoard(board){
    const racers=new Set(RACERS.map(c=>c.id));
    let maxSpace=-Infinity; for(const k of board.keys()) if(k>maxSpace) maxSpace=k;
    const order=[];
    for(let s=maxSpace; s>=-100; s--){ if(!board.has(s)) continue; const stack=board.get(s); for(let i=stack.length-1;i>=0;i--){ const cid=stack[i]; if(racers.has(cid)) order.push(cid); } }
    const placement=new Map(); order.forEach((cid,idx)=> placement.set(cid, idx+1));
    return placement;
  }

  // === Interactive state ===
  let legBoard; // Map space->stack
  let usedDice; // array of ids in order (e.g., ['red','grey','blue'])
  let finished;

  function resetLeg(){
    legBoard = buildInitialBoard();
    usedDice = [];
    finished = false;
    drawBoard(legBoard); // preview uses setup preview for convenience
    updateUsedDiceLine();
    el('#placementStats').innerHTML = 'Make an input to see stats…';
    el('#status').textContent = '';
  }

  function updateUsedDiceLine(){
    if(!usedDice.length){ el('#usedDiceLine').textContent = 'No inputs yet.'; return; }
    const names = usedDice.map(d=> d==='grey' ? 'Grey' : (RACERS.find(x=>x.id===d)?.name||d));
    el('#usedDiceLine').textContent = `Inputs this leg: ${names.join(', ')}`;
  }

  // Apply a single user-specified move to the live leg board
  function applyUserMove(die, roll){
    if(finished){ el('#status').innerHTML = '<span class="error">Leg already finished.</span>'; return false; }
    if(usedDice.includes(die)){ el('#status').innerHTML = '<span class="error">That die was already used this leg.</span>'; return false; }
    if(usedDice.length>=5){ el('#status').innerHTML = '<span class="error">A leg has exactly 5 dice.</span>'; return false; }

    if(die==='grey'){
      const crazy = Math.random() < 0.5 ? 'black' : 'white';
      const loc = locate(legBoard, crazy); if(loc.space!==-1){
        const movers = legBoard.get(loc.space).slice(loc.index);
        const stayers = legBoard.get(loc.space).slice(0,loc.index);
        if(stayers.length) legBoard.set(loc.space,stayers); else legBoard.delete(loc.space);
        const dest = Math.max(0, loc.space - roll);
        const destStack = legBoard.get(dest) || [];
        destStack.push(...movers); legBoard.set(dest, destStack);
      }
    } else {
      const loc = locate(legBoard, die); if(loc.space!==-1){
        const movers = legBoard.get(loc.space).slice(loc.index);
        const stayers = legBoard.get(loc.space).slice(0,loc.index);
        if(stayers.length) legBoard.set(loc.space,stayers); else legBoard.delete(loc.space);
        const dest = loc.space + roll;
        const destStack = legBoard.get(dest) || [];
        destStack.push(...movers); legBoard.set(dest, destStack);
        const trackLen=parseInt(el('#trackLen').value,10)||16;
        if(dest>=trackLen) finished = true;
      }
    }
    usedDice.push(die);
    updateUsedDiceLine();
    drawBoard(legBoard);
    el('#status').textContent = '';
    return true;
  }

  // Complete the remainder of the leg randomly, given current state & usedDice
  function simulateRemainderOnce(trackLen){
    // clone board
    const board = new Map(); for(const[k,v] of legBoard.entries()) board.set(k, v.slice());
    let done = finished;
    const remainingAll = ['blue','green','red','yellow','purple','grey'].filter(d=>!usedDice.includes(d));
    // pick up to (5 - usedDice.length) dice uniformly at random from remainingAll, in random order
    const need = Math.max(0, 5 - usedDice.length);
    const bag = shuffle(remainingAll).slice(0, need);
    for(const die of bag){ if(done) break;
      if(die==='grey'){
        const crazy = Math.random() < 0.5 ? 'black' : 'white';
        const roll = 1 + Math.floor(Math.random()*3);
        const loc = locate(board, crazy); if(loc.space!==-1){
          const movers=board.get(loc.space).slice(loc.index);
          const stayers=board.get(loc.space).slice(0,loc.index);
          if(stayers.length) board.set(loc.space,stayers); else board.delete(loc.space);
          const dest=Math.max(0, loc.space - roll);
          const destStack=board.get(dest)||[]; destStack.push(...movers); board.set(dest,destStack);
        }
      } else {
        const roll = 1 + Math.floor(Math.random()*3);
        const loc = locate(board, die); if(loc.space!==-1){
          const movers=board.get(loc.space).slice(loc.index);
          const stayers=board.get(loc.space).slice(0,loc.index);
          if(stayers.length) board.set(loc.space,stayers); else board.delete(loc.space);
          const dest=loc.space + roll; const destStack=board.get(dest)||[]; destStack.push(...movers); board.set(dest,destStack);
          if(dest>=trackLen) { done = true; break; }
        }
      }
    }
    return placementsFromBoard(board);
  }

  function runSimulationsForCurrentState(){
    const sims = clamp(parseInt(el('#sims').value||500,10),1,100000);
    const trackLen = clamp(parseInt(el('#trackLen').value||16,10),6,40);
    // tally 1..5
    const stats=new Map(); RACERS.forEach(c=> stats.set(c.id,[0,0,0,0,0]));
    for(let i=0;i<sims;i++){
      const placement = simulateRemainderOnce(trackLen);
      RACERS.forEach(c=>{ const p=placement.get(c.id); if(p>=1&&p<=5){ const a=stats.get(c.id); a[p-1]++; } });
    }
    renderPlacementStats(stats, sims);
  }

  function renderPlacementStats(stats, total){
    const container=el('#placementStats');
    let html='<table><thead><tr><th>Camel</th><th>1st</th><th>2nd</th><th>3rd</th><th>4th</th><th>5th</th></tr></thead><tbody>';
    RACERS.forEach(c=>{
      const arr = stats.get(c.id)||[0,0,0,0,0];
      const pct=n=> total? ((n/total*100).toFixed(1)+'%') : '0.0%';
      html+=`<tr><td style="text-align:left">${c.name}</td>`+
            `<td class="mono">${arr[0]} <span class="note">(${pct(arr[0])})</span></td>`+
            `<td class="mono">${arr[1]} <span class="note">(${pct(arr[1])})</span></td>`+
            `<td class="mono">${arr[2]} <span class="note">(${pct(arr[2])})</span></td>`+
            `<td class="mono">${arr[3]} <span class="note">(${pct(arr[3])})</span></td>`+
            `<td class="mono">${arr[4]} <span class="note">(${pct(arr[4])})</span></td>`+
            `</tr>`;
    });
    html+='</tbody></table>';
    container.innerHTML=html;
  }

  // === Init ===
  function updatePreview(){ drawBoard(buildInitialBoard()); }
  function init(){
    buildRows();
    el('#setup').addEventListener('input', updatePreview);
    el('#trackLen').addEventListener('input', updatePreview);
    updatePreview();

    el('#applyBtn').addEventListener('click', ()=>{
      const die = el('#dieSelect').value;
      const roll = parseInt(el('#moveSelect').value,10);
      if(applyUserMove(die, roll)) runSimulationsForCurrentState();
    });
    el('#undoBtn').addEventListener('click', ()=>{
      if(!usedDice.length){ el('#status').innerHTML = '<span class="error">Nothing to undo.</span>'; return; }
      // full recompute from start (simplest & safest)
      const history = usedDice.slice(0,-1);
      resetLeg();
      for(const d of history){
        const wasGrey = d==='grey';
        // we cannot know the exact 1-3 user chose before; assume the move select currently shows the intended values.
        // To be deterministic, we store nothing extra; encourage immediate re-entry.
        break; // inform user instead of guessing
      }
      el('#status').innerHTML = '<span class="note">Last input undone. Re-enter it as needed.</span>';
    });
    el('#resetBtn').addEventListener('click', resetLeg);

    // Start fresh
    resetLeg();
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded',init); else init();
})();
</script>
</body>
</html>
